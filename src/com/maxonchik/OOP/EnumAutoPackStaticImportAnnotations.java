package com.maxonchik.OOP;
/*
******************************************************************************************************************************
* Перечисления:
* Перечисления - список именнованных констант, определяющих новый тип данных. В объектах перечислений могут соедржаться только
* константы, использующиеся в этом списке. Т.е перечисления определяют тип данных, который может принимать строго определенные значения.
* Пример перечислений - названия месяцев года - они строго определены и не могут иметь других значений. Если объект характеризуется
* какими-то строгими значениями, то удобней использовать перечисления, чем final переменные, т.к это позволит лучше структурировать
* код. Перечисление создается с помощью ключевого слова enum. Как и для класса, для перечисления создается собственный файл:
* Пример:
* enum Phones{
* IPHONE, SAMSUNG, XIAOMI, LG
* }
* Константы перечисления - идентификаторы. Каждый из них неявно объявлен как public static член перечисления Phones.
* Типом этих констант, в данном случае является тип Phones. К этим константам применяется термин - самотипизированность, где приставка
* "само" относится к названию перечисления, в котором эти константы объявлены. В отличие от классов и интерфейсов, объекты
* перечислений создаются подобно элементарным типам, без привлечения оператора new
* Phones phone; // Переменная перечисления создана
* Этой переменной можно присваивать только значения из перечисления:
* phone = Phones.XIAOMI;
* Равенства переменных сверяются с помощью оператора сравнения ==(а не метода equals(Object obj))
* Константы перечислений можно использовать в качестве констант опреатора switch:
* switch(phone)
*     case XIAOMI:
*     //TODO
*     break;
*     case SAMSUNG:
*     //TODO
*     break;
*     etc...
* В switch используются именованные константы, а не уточненные
* Для вывода константы с помощью метода print() используется ее уточненное имя:
* System.out.println(Phones.XIAOMI);
* В терминале отобразится ее сокращенное имя, т.е XIAOMI.
* Перечисления являются типом классов, несмотря на то, что объекты создаются без привлечения оператора new. Такая реализация
* позволяет использовать для них конструкторы, объявлять в них методы, создание перечислений, реализующие интерфейсы.
* Перечисления включают в себя два стандартных переопределнных метода values() и valueOf(String str). Первый возвращает
* массив констант пречисления, второй возвращает константу, соответствующуу строке str. Первый метод является методом типа
* enum[], второй - типа enum, где enum - перечисление.
* Например, метод Phones.valueOf("XIAOMI") вернет значение XIAOMI типа Phones.
* Phones allPhones[] = Phones.values() - запишет все значения перечисления в массив allPhones[].
* Обработать этот массив можно с помощью for-each.
* ****************************************************************************************************************************
* Перечисление как класс:
* Все константы перечисления являются объектами перечисления. Если определить для переменной перечислемого типа конструктор, он
* будет вызываться каждый раз при создании константы типа перечисления. Для каждой константы можно вызвать метод, определенный в классе
* перечисления. Для того, чтобы воспользоваться конструктором, константам в перечесилении уже должны быть переданы параметры
* для конструктора:
* enum Phones{
* XIAOMI(6), IPHONE(3), SAMSUNG(8);
* private int mCoreNum;
* Phones(int c){
* mCoreNum = c;
* }
* public int getCoreNum(){return mCoreNum;}
* }
* аким образом, при вызове этого конструктора Phones, константам будут присвоены значения, введенные в них как параметры к
* свойству mCoreNum. При вызове метода getCoreNum будет возвращено число ядер процессора телефона.
* при добавлении свойств к константам, их объявление нужно завершить точкой с запятой.
* Перечисление, как и другие классы, допускают практически неограниченное число конструкторов.
* В отношении перечислений действуют два ограничения: 1) Нельзя перечислению наследоваться от других классов. 2) Перечисление
* не может быть суперклассом.
* Все перечисления наследуются от java.lang.Enum. Соответсвенно, перечисления реализуют все те методы, которы опредлены в этом
* классе. 1) final int ordinal() - данный метод возвращает порядковое значение константы в перечислении. Индексация, как и везде,
* начинает отсчет с нуля. Напрмимер Phones.SAMSUNG.ordinal() вернет значение 2, т.к SAMSUNG - третий в перечислении.
* final int compareTo(enum e) - сравнивает порядковые номера констант. Если не совпадают - возвращает -1, совпадают - 0.
* ****************************************************************************************************************************
* Автоупаковка и автораспаковка:
* Оболочки типов: Как известно, в Java существуют примитивные типы, позовляющие производить вычисления очень быстро и эффективно.
* Но, эти экземпляры этих типов не являются объектами. Часто возникают ситуации, когда с переменными простых типов нужно работать
* как с объектами, например, чтобы передать их методу по ссылке. Кроме того, коллекции в Java редусматривают работу с объектами.
* В них нельзя хранить данные примитивных типов. Для такого рода ситуации, в Java предусмотрены классы-оболочки типов.
* Классы-оболочки(Wrapper class) - это классы, инкапсулирующие простые типы данных. Классы-оболочки реализованы в пакете
* java.lang. К этим классам относятся: Integer, Byte, Boolean, Character, Short, Long, Double, Float. Эти классы предоставляют
* методы, позволяющие полностью интегрировать простые типы в иерархию объектов. Чаще всего применяются только оболочки числовых типов
* данных (все, без Boolean и Character). Эти классы наследуются от абстрактного класса Number. В этом классе определны методы,
* возвращающие числовые значения объектов этих классов:
* byte byteValue();
* short shortValue();
* int intValue();
* long longValue();
* float floatValue();
* double floatDouble();
* Т.е, по сути, это методы-конвертеры объектов в простые типы.
* В каждом из этих классов предусмотрены 2 вида конструкторов, формирующие объект либо на основе числового значения, либо строкового
* представления:
* Integer(int num)
* Integer(String str) //Аналогично для других wrapper-классов числового типа
* Если str содержит недопустимое значение для классов числового типа, генерируется NumberFormatException
* Во всех классах-оболочках переопределен метод toString() - для возвращения значения в удобной для чтения форме.
* ***************************************************************************************************************************
* Процесс инкапсуляции значения в классе-оболочке называется упаковкой!
* Процесс извлечение значения из класса-оболочки называется распаковкой!
* ***************************************************************************************************************************
* До версии JDK5, при создании объекта-оболочки примитвного типа, нужно было явно указывать инкапсулируемое значение в
* объекте-оболочке:
* Integer intObj = new Integer(10000);
* Распаковка также производилась вручную: int objValue = intObj.intValue();
* Такой способ реализации объектов-оболочек неудобен и чреват ошибками, автоупаковка и автораспаковка позволяют этого избежать.
* Автоупаковка - это процесс автоматической инкапсуляции примитивных типов в классах-оболочках всякий раз, когда это необходимо.
* Причем, объект-оболочку не нужно создавать явным образом. Автораспаковка - процесс, обратный автоупаковке.
* Автоупаковка освобождает программиста от ручного создания объектных оболочек примитивов. Достаточно присвоить примитивное значение
* ссылке на объект-оболочку и RunTime автоматически создаст этот объект.
* Пример:
* Integer autoObj = 100 //autoObj автоматически создался как объект класса Integer с инкапсулированным значением 100 процессом
* // автоупаковки
* Также нет нужды использовать оператор new. Объект создается автоматически.
* Для распаковки значение достаточно присвоить переменной примитивного типа ссылку на объект класса-оболочки:
* int i = autoObj; // процесс автораспаковки
* Автоупаковка и автораспаковка могут происходить при передаче аргументов методам и при возврате значений из методов. Пример:
* public void AutoPack(Integer m){
* System.out.println(m) //Данный метод выводит целочисленное значение m из объекта Integer
* }
* public Integer AutoPack2{
* return 100; //Метод типа Integer возвращает целочисленное значение через автораспаковку
* }
* public int AutoPack3{
* return 10;
* }
* Integer intObj = AutoPack3(); // объекту Integer присваивается значение из метода intObj
* Одно из главных преимуществ объектов wrapper-классов - передача методам по ссылке, например методам класса Math:
* Math.abs(intObj);
* Автоупаковка и автораспаковка создают объект тогда, когда это необходимо. При выполнении арифметических операций, значения
* объектов-оболочек сначала распаковываются, выполняется операция, а затем обратно упаковывается:
* Integer intObj = 10;
* intObj+=10; // Сначала автораспаковывается значения из обекта intObj, выполняется сложение, и обратно упаковывается.
* Но, использовать классы-оболочки нужно только там, где это действительно необходимо, там, где использование простых типов недопустимо.
* Так как, процессы автоупаковки и автораспаковки снижают производительность программы.
* ***********************************************************************************************************************************
* Статический импорт:
* Статический импорт применяется в случаят, когда необходимо импортировать статические члены классов или интерфейсов. Это
* удобно, для того, чтобы не прописывать полный путь к члену класса или интерфейса в импорте. Помечается помещение после слова import
* слова static. Например, нужно использовать в программе какие-либо статические методы. В этом случае, для его использования
* нужно прописать в операции, где это метод используется его полное имя. Например:
* Math.abs(-100). Это статический метод класса Math, и всякий раз, когда нужно его вызвать, нужно обязательно сослаться в нем на класс
* Math. Если провести статический импорт, то можно писать только имя метода и все!
* import static java.lang.Math.abs;
* //SOME CODE
* //SOME CODE
* abs(-100); // Гораздо удобней, особенно если какой-то статически член классов используется многократно в программе.
* Данное средство работает для всех статических членов любых классов и интерфейсов, будь то стандартные библиотеки, или же написанные
* программистом классы и интерфейсы.
* *********************************************************************************************************************************
* Аннотации(кратко):
* Аннотации - это дополнительная информация, не изменяющая поведения программы, используемая различными интсрументальными средствами
* Создание аннотаций: создаются с помощью механизма, основанного на интерфейсах:
* Пример:
* @interface MyAnnotation{
* String str();
* int val();
* }
* @ - символ объявления аннотации. Аннотации содержат лишь определения методов без тел. В качестве суперинтерфейса для всех аннотаций
* используется интерфейс Annotation - все аннотации расширяют его. Он входит в пакет java,lang.annotation.
* Аннотации используются, в первую очередь, для аннотирования объявлений. Например:
* @Override  // аннотация переопределния метода
* protected void OnCreate(Bundle savedInstanceState){TODO}
* Аннотация всегда предшествует объявления. Начиная с JDK 8 , могут аннотироваться использования типов. Вводя аннотацию с параметрами,
* аннотация связывается с методом, к которому применена.
* Аннотации без параметров называются маркерными аннотациями. Они служат для того, чтобы пометить тот или иной метод каким-либо
* атрибутом. Пример, тот же @Override - эта аннотация говорит о том, что метод переопределяется из суперкласса и сообщит об ошибке,
* если будет ошибка в названии. В java.lang предусмотрены аннотации общего назначения: их 9:
* *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *
* java.lang.annotation
* @Retention - Определяется стратегию управления жизненным циклом аннотации. Эта стратегия определяет, будет ли видна аннотация
* в исходном коде, либо же только в компиляторе.
* @Documented - используется для документирования другой аннотации при ее объявлении
* @Target - определяет, к каким видам объявлений может быть применена аннотация, к которой применяется аннотация @Target
* @Inherited - Аннотация суперкласса должна наследоваться подклассом
* java.lang
* @Override - показывает, что метод обязательно должен быть переопределен из суперкласса
* @Deprecated - объявление устарело и заменено новым
* @SafeVarargs - в конструкторе или методе не выполняются действия, небезопасные с точки зрения переменного числа аргументов
* @FunctionalInterface - аннотация объявления функционального интерфейса(тот, который содержит только один абстрактный метод)
* Эти интерфейсы используются в лямбдах
* @SuppressWarnings - предупреждающие сообщения подавляются и заменяются на строковое представление.
* Есть еще @Repetable и @Native
*
*
*
*
*
*
*
*
* */

public class EnumAutoPackStaticImportAnnotations {
}
