package com.maxonchik.OOP;
/*Класс с информацией об обобщениях, они же дженерики*/
/*Дженерики - это абсолютно новая синтаксическая конструкция, введенная в JDK 5. Обоббщение представляет собой параметризованный тип.
* Специфика таких типов состоит в том, что в классах, методах их можно указывать в виде параметров. Такие классы или метода, исполь-
* зующие дженерики в качестве параметров называют обобщенными. Преимущество такого кода состоит в том, что он будет автоматически
* работать с типом данных, переданным ему в качестве параметра. С помощью обобщений можно реализовать какой-либо алгоритм один раз
* и применять его к любому типу данных. Раньше, когда дженериков не было, можно было использовать объекты любых типов посредством
* работы с ссылкой на тип Object, но такие преобразования могли быть неумышленно выполнены неверно. Дженерики же обеспечивают
* безопасное и точное приведение типов. Дженерики расширяют возможности повторного и безопасного использования кода.
* Пример в коде в классе GenDemo
* Синтаксис:
* ClassOrMethod <Type> - Type в угловых скобках - это тип-заполнитель - данный тип меняется при использовании данного класса в
* любом случае. Рекомендуется прописывать тип в виде одной прописной буквы, например <T>, <V>, <E> и т.д.
* Обобщенный тип можно возвращать в виде значения в методе.
* При присваивании обобщенного типа, компилятором не создается никакая специфическая версия обобщенного класса. Все происходит
* так, будто создается специфическая версия, но в реальности, происходит простое удаление информации о специфическом типе и
* замещении его на наш введенный тип. Этот процесс называется очисткой.
* В обобщенном классе с присвоенным типом нельзя хранить данные других типов, например если мы присвоили тип <Integer>, то
* нельзя хранить в нем значения типа <Double>, например.
* Обобщения работают только с объектами, нельзя в обобщенный тип вставить примитивный тип, выйдет ошибка. Если нужно использовать
* числовой тип, используются wrapper-классы примитивных типов.
* Ссылки на объекты одного обобщенного типа, но разного присвоенного несовместимы между собой(логично, это разные объекты разных типов)
* Дженерики допускают использование нескольких параметров типов, для того, чтобы их использовать, нужно прописать их через запятую:
* Дженерики в таком виде позволяют применять код в ним для любых типов, но иногда, логически правильно ограничивать выполнение их
* кода только для определенного списка типов, допустим, только для чисел. В таком случае используется ключевое слово extends:
* public class SomeClass <T extends SuperClass> // T extends SuperClass оворит о том, что в качестве передаваемого обобщенному классу
* типа может использоваться только тип SuperClass или его наследники. Например если написать <T extends Number>, то в качетсве
* параметра могут выступать только Number, Integer, Double и т.д. Такие типы называют ограниченными.
* Ограниченные типы используются часто для обеспечения совместимости одного типа с другим: например:
* class Class <T, V extends T> - то значит, что типы должны быть совместимы друг с другом
* То есть, V олжен быть такой же, как и T, ибо его подклассом.
* Шаблоны аргументов:
* Шаблон аргумента нужен для проведения операции между несколькими разными типами данных. Обозначается как <?>.
* Метасимволу ? соответствует неизвестный тип данных. Применяется к обобщенным классам, инкапсулирующим несколько типов данных.
* Например есть class A:
* class A <T, V extends T> . При использовании какого-либо метода к объекту этого класса, например, можно указать SomeMethod(A<?>),
* что соответсвует неизвестному типу данных из класса A.
* Ограниченные шаблоны: Шаблоны аргументов также можно ограничивать. Это особенно полезно тогда, когда нужно, что методы оперировали
* только подклассами определенного суперкласса. Пример:
* Допустим, есть 3 класса: A, B, C. B и C - наследники класса А. Нам нужно оперировать только типами этих классов, тогда синтаксис
* будет следуюший: Generics<? extends A> - т.е неизвестный тип наследует или является классом А.
* По ситуации, можно указать нижнюю границу иерархии классов, которая может передаваться в качестве аргументов, использованием super:
* Generics<? super какой_нибудь_подкласс>
* В данном случае допускается использовать только суперклассы этого подкласса, включая его самого
* Обобщенные методы:
* Методы в обобщенных классах, принимающих на вход обобщенный тип автоматически становятся обобщенными, но обобщенные методы
* можно использовать и в пределах обычного класса, достаточно указать ему на вход обобщенный тип.
* Синтакси объявления обобщенного метода:
* public static <T extends Comparable<T>, V extends T> boolean arraysEqual(T[] x, V[] y){}
* Параметры типа объявляются перед возвращаемым типом. Т наследует интерфейс Comparable<T>, определенный в пакете java.lang.
* Это интерфейс, который реализуют все сравниваемые объекты, т.е если установить в качестве верхней границы реализацию этого
* интерфейса типом Т, то на вход не смогут подаваться несравниваемые объекты. Например, все массивы реализуют Comparable.
* Интерфейс Comparable - обобщенный, его параметр типа задает тип сравниваемых объектов. V наследуется от T, то есть может быть
* либо Т, либо его подклассом. В данном методе, это говорит о том, что на вход могут подаваться только массивы, которые можно
* сравнивать между собой.
* Обобщенные конструкторы:
* Конструктор класса может быть обобщенным, даже если класс не является обобщенным.
* Синтаксис обобщенных конструкторов:
* class A{
* //TODO
* <T extends Number> A(T val){someObj = val;} В данном случае, класс А не является обобщенным, но обобщенным является его конструктор
* Перед именем конструктора класса определяются параметры типов, в данном случае, конструктор ограничен типом Number, т.е на вход
* идут значения типа Number и его наследников: Integer, Double и т.д.
* Обобщенные интерфейсы: Как и классы, методы и конструкторы, интерфейсы также могут быть обобщенными. Пример был выше, реализация
* Comparable<T>. Разумеется, можно реализовывать любой обобщенный интерфейс:
* public interface A<T>{
* boolean someMeth(T obj){return true;};
* }
* public class B<T> implements <T>{
* // Класс, реализующий обобщенный интерфейс, тоже должен быть обобщенным.
* @Override
* someMeth(new T);
* Если для интерфейса указан конкртеный тип данных в дженерике, то классу необязательно быть обобщенным.
* Если интерфейс использует ограниченный тип, то класс тоже использует этот же самый ограниченный тип:
* public interface I <V extends Number> - интерфейс использует только числовой тип
* Теперь любой класс, который реализует этот интерфейс должен передавать ему значения того же типа:
* public class A<V extends Number> implements I<V>. Так как уже задана верхняя граница в классе, то нет нужды объявлять ее в интерфейсе.
* При попытке определить верхнюю границу в интерфейсе, компилятор выведет ошибку.
* Автоматическиое определние аргументов типов:
* До JDK 7, обобщенные обхекты нужно было определять следубщим образом:
* class A<Integer, String>{
* A<Integer, String> obj = new A<Integer, String>(35,"string");
* }
* Эта форма объявления достаточно громоздка, поэтому существует сокращенный синтаксис объявления:
* A<Integer, String> obj = new A<>(35,"string");
* устые угловые скобки говорят о том, что компилятору предлагается самостоятельно определить, какие типы переданы в объект.
* Очистка:
* При введении дженериков, разработчики учитывали в первую очередь, совместимость с уже существующим кодом, чтобы изменения
* в JVM не нарушали его работоспособность. Поэтому, разработчики ввели механизм, называемый очисткой:
* Очистка - механизм компиляции, при котором вся существующая информация об обобщенных типах в коде удаляется. Это реализуется
* следующим образом: верхние границы параметров типов заменяются на эти самые верхние границы, если границы не указаны, то
* функцию параметров типов выполняет класс Object. Потом, выполняется приведение аргументов, азданных параметром типа.
* Это значит, что обобщения есть только в исходном коде, но не в программе.
* Неоднозначность:
* Ошибки неоднозначности: допустим, есть обобщенный класс:
* class A<V,T>
*     V o1; // 2 объекта двух как-бы разных типов
*     T o2;
* void set(V o){o1 = o}
* void set(T o){o2 = o}
* Типичная перегрузка методов: вроде все хорошо, метод один, пердаются два разных объекта, но откуда нам точно известно,
* что введенные в класс типв действительно буду разными? Если они будут одинаковы, то метод set получится один и тот же,
* что в любом случае - ошибка. Следовательно, возникает ошибка неоднозначности. Реашется путем работы с каждым типом непосредственно,
* например, вызвать метод set для V и set1 для T.
* Ограничения в использовании дженериков:
* Нельзя создать объект дженерика - логично, так как дженерик является просто заполнителем:
* class A<T>{
* T obj = new T; // ОШИБКА КОМПИЛЯЦИИ!!! НЕЛЬЗЯ!!!
* }
* Нельзя использовать дженерики в статических членах классов!
* static T obj; // ОШИБКА!
* Ограничения работы с обобщенными массивами:
* Обобщенный массив создать можно:
* T[] arr // Можно!
* Но нельзя этот массив присвоить существующему:
* arr = new Integer[]{1,2,3,4,5} // Ошибка!!!
* Также, нельзя создать массив обобщенного типа с заданной длиной массива, т.е такой массив не индексируется:
* arr = new T[10] //ОШИБКА!!!
* Обобщенные классы не могут расширять Throwable, то есть нельзя создавать с таких классов исключения.
* */
public class Generics <G, T>{//Обобщенный класс Generics принимает обобщенный тип G, вместо которого подставляется реальный тип данных
    G GenObject;//Создали объект обобщенного типа
    T TenObject;
    Generics(G g, T t){GenObject = g; TenObject = t;} //онструктор объектов обобщенного типа G

    G showType(){ //метод showType имеет тип G в качестве возвращаемого значения
        System.out.println("Тип дженерика это "+ GenObject.getClass().getName());
        System.out.println(TenObject.getClass().getName());
        return GenObject;

    }
}
