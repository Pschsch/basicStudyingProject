package com.maxonchik.OOP;  /*Acorn Games или Pschsch */

public class NewBigStepInJavaStudying {

    /*Любой, написанный на Java код находится в пределах класса. Классы составляют саму суть всего языка Java, являются его
 фундаментом. Класс - это шаблон, по которму определяется вид создаваемого объекта. объекты - экземпляры классов.
 Важно! Класс - это логическая абстракция, физическое представление класса в ОЗУ появится лишь тогда, когда будет
 создан объект этого класса. Методы и переменные класса - члены класса.
 Как правило, классы содержат и код, и переменные(так и есть в 99% случаев). Класс создается с помощью ключевого
 слова class. Правил синтаксиса как таковых нет. однако класс вмещает только одну логическую сущность. В правильно сконструированном
 классе должна содержаться только логически связанная информация. Если информация не связанна, то структура кода сильно нарушается.
 Объявление класса - это всегда создание нового типа данных. Классы - это описание абстрактных сущностей в ООП
 В классах описываются свойства, которые характерны для объектов этого класса. Объекты класса, в свою очередь, обладают
 конкретными значениями свойств класса. Помимо объектов, классы содержат методы ( функции ), которые могут быть
 применины как для данного класса, так и для всех классов в пакете или любой точке программы ( зависит от модификаторов доступа)
 Всякий раз при создании объекта в классе, классу присваиваются собственные значения переменных класса. Чтобы обратиться к переменной конкретного
 объекта используется ТОЧЕНЧАЯ НОТАЦИЯ: Например: camry.Wheels=4; Нотации используются и для обращения к методам от имени объектов.
 Одно из главных правил Java - Один класс - один файл.
 Процедура создания объекта: сначала объявляется переменная класса, которая будет ссылкой на объект в памяти. Далее с помощью
 оператора new создается его физическая модель.
 Оператор new - его назначение: динамически (во время выполнения программы)выделяет память для объекта и возвращает ссылку на него.
 По сути, имя объекта - это адрес ячейки памяти с данными объекта. выделяемой оператором new. Таким образом, память для всех
 объектов выделяется динамически.
 Vehicle = camry; - ссылка  camry = new Vehicle - создание в ОЗУ объекта camry класса Vehicle. Ссылка начинает ассоциироваться с объектом
 только после выполнения присваивания имени переменной объекту, это следует помнить. Грубо говоря, нужно присваивать имя переменной
 объекту в начале программы.
 При выполнении операции присваивания одной переменной другой переменной ссылочного типа, они становятся "одинаковыми адресами"
 объекта, который создан с присваиванием ему одной из таких переменных.
 Vehicle camry = new Vehicle;
 Vehicle toyota = camry; toyota и camry - один и тот же объект класса Vehicle, toyota сылается на ту же ячейку памяти.
 Кроме ссылки на один и тот же объект в данный момент времени выполнения программы, эти переменные больше ничего не связывает.
 Если переменную toyta дальше присвоить к какой-нибудь другой переменной другого объекта, toyota станет ссылаться на это объект,
 никак не повлияв на объект camry.
 Методы - подпрограммы, манипулирующие данными в классе. Во многих случаях, предоставляют доступ к этим данным. Как правило, другие
 части программы взаимодействуют с классом посредством его методов. Каждый метод содержит одну или несколько инструкций.
 В правильно написанной программе, метод выполдняет только ОДНУ ФУНКЦИЮ. У метода есть имя, которое используется для его вызова.
 Например, метод System.out.println(); - println - метод класса System. Следует иметь в виду, что название main() зарезервировано
 для метода, с которого начинается выполняться программа.
 Общий синтаксис: тип название(параметры метода){
 тело метода
 }
 Тип метода - тип данных, возвращаемых методом. Это может быть все допустимые типы данных, типы классов. если метод не возвращает
 никаких значений, то указывается тип метода void(ключевое слово). Параметры метода - переменные, объявляющие в этом блоке
 передаются методу и доступны только внутри него. Добавлять методы в классы и использовать их в классе и за его пределами умею)
 void range(){System.out.println("Дальность - "+fuelcap*mpg+" миль")}
 Возврат из метода: (под возвратом здесь подразумевается досрочный выход)для выполнения возврата необходимо 2 условия: 1) необходимо наличие закрывающей фигурной скобки - это
 признак завершения метода и возможности возврата из него значений. 2) выполнение опретаора return.
 оператор return: данный оператор применяется для немедленного завершения метода и возврата из него значений.
 Существует 2 вида оператора return: 1) для метода void, который не возвращает значение 2) возвращает значение вызывающей части
 программы. Чтобы сделать возврат из метода необходимо наличие в коде оператора return:
 Синтаксис:
 return;
 Пример программы:
 void ForLoop(){
    for(i=0; i<100; i++){
        System.out.println(i);
    if(i==5) return;
        }
    }
    Когда значение i из цикла for достигнет 5, произойдет завершение цикла и возврат из метода.
    В одном методе может быть несколько операторов return. Это необходимо, если в методе прописано несколько вариантов
    выполнения(например, с помощью условия if):
    void AlternateCondit(){
    if(условие)return;
    //...
    if(другое условие)return;
    //...
    }
    C return, акже как и с break и continue - очень аккуратно и продуманно пользоваться, там. где это действительно нужно,
    в противном случае, нарушается структура кода. Итак, таким образом, метод void завершается двумя способами: по достижению
    закрывающей фигурной скобки и при выполнении оператора return.
    Возврат значения: Несмотря на то, что войдовские методы встречаются часто, большинство методов значения возвращают.
    Это свойство относится к одним из самых полезных свойств метода. Например, метод sqrt() класса Math возвращает значение
    квадратного корня введеного аргумента. Возвращаемые значения используются для самых разныйх целей в программировании.
    2 основных вида таких целей: 1) Возврат значения после выполнения некоторых расчетов в методе, 2) Сообщение об успешном
    выполнении инструкций метода. приведем пример метода, возвращающий значение:
    public int MethodReturningValue(){
    return 25+25;
    } Метод вернет значение 50.
    Можно присвоить возвращаемое методом значение какой-лиюо переменной: например:
    var1=obj.MethodReturningValue; где - var1 - переменная, которой присваивается значения того же типа, что и метод.
    obj - какой-то объект, для которого выполняется метод. MethodReturningValue - соответсвенно метод. Важно! метод должен быть
    того же типа, что  и тип возвращаемого значения(логично какбэ). Значение, возвращаемое методом, необязательно присваивать
    какой-либо переменной, чтобы, например, вывести его на экран. В методе print() можно сразу ввести название метода, и он
    отобразит возвращаемое методом значение. В этом случае, при исполнении метода print() вызывается введеный нами метод в качестве
    параметра, возвращает значение и передает его методу print(). К методу можно обращаться всегда, когда нам необходимо
    его возвращаемое значение.
    Например: if (obj.MethodReturningValue()==50) System.out.println("Значение метода равно 50");
    Использование параметров: при вызове метода, ему можно передать одно или несколько значений. Эти значения называются
    аргументами, а переменная, получающая аргумент называется параметром. параметры указываются в скобках, после имени метода.
    Синтаксис объявления параметров такой же, как и у переменных: boolean SomeMethod(int l) - boolean - тип возвращаемого значения,
    int l - параемтр l типа int метода SomeMethod. Областью действия параметров является тело метода.
    Например: boolean SomeMethod (int l){
    if (l%2==0) return true;
    else return false; //метод возвращает значение true , если l четное, если нечетное возвращает false.
    }
    передача аргумента происходит при вызове метода непосредственно: obj.SomeMethod(25). Этот метод с введеным значением аргумента
    25 вернет значение false.
    Метод может иметь несколько параметров. Параметры записываются через запятую. Для каждого параметра записывается тип.
    ///
    При правильном построении программы, как уже говорилось, класс должен выполнять строго определенный набор функции, должен
    быть как можно более коротким, но в разумных пределах. Ведь классы, реализующие лишние функции, становятся более сложными для восприятия
   и структура их кода портится. Но классы со слишком ограниченным кругом возможностсей делают программу сильно фрагментированной.
   Чтобы найти золотую середину в этом вопросе, необходимо нарабатывать опыт в "искусстве программирования."
   Упражнение: необходимо преобразовать блок справочной системы из главы 3 в класс в качестве методов.
   Конструкторы объектов в Java.
    По умолчанию, при создании объекта, он создается без каких-либо параметров. Т.е после создания
    объекта, необходимо вручную прописывать ему все свойства. В Java объект создает конструктор.
    Конструктор - это специальный метод, использующийся для инициализации свойств объекта.
    Конструктор отличается от метода тем, что не возвращает данные и называется так же, как и класс.
    Конструкторы бывают 2-х типов: 1-й тип: конструктор  приписывает объекту заданное значение при создании.
    Например:
    public class Class1{
    int x;
    Class1(){
    x=10  /Т.е при создании объекта, конструктор автоматом присвоит ему значение x равным 10
    }
    }
    2-й тип: параметризованный конструктор: конструктору задаются параметры, которые необходимо вводить при создании объекта
    в его параметрах.
    Например:
    Class 1(int i){
    x=i
    } т.е свойство i задается и присваивается параметру x при создании объекта класса Class1. В IntellijIdea при начале набора
    значений, высветится свойство для которого вводится значение.
    Конструкторов может быть практически неограниченное количество. Чтобы программе определить,
     какой конструктор вы хотите использовать, необходимо вводить переменные в том порядке, в котором
     они указаны в конструкторе. Конструкторы можно сокращать при использовании в наследуемых
     классах с помощью оператора super.(о наследовании дальше подробнее).
     Оператор new - общий синтаксис:
     класс переменная_класса = new имя_класса(список аргументов);
     имя_класса(список аргументов) - конструктор объектов этого класса. Если в классе конструктор не предусмторен, используется
     конструктор по умолчанию. Оператор new возвращает ссылку на созданный объект, который получает переменная_класса.
     Основная сложность, которая может возникнуть при генерации в памяти объекта - это, собственно, недостаток памяти для
     создания объекта. поэтому важно, чтобы ОЗУ своевременно очищалась от неиспользуемых объектов для последующего распределения
     ОЗУ для других используемых объектов. Для этого в Java предусмотрена система сборки мусора, так называемая. Эта система действует
     автоматически, без вмешаетльства программиста. Она осуществляется время от времени по ходу выполнения программы. Чтобы избежать
     снижения производительности, сборка мусора выполняется при 2-х условиях: сущетсвуют объекты , подлежащие удалению и есть необъодимость освободить
     занимаемую ими память.
     Метод finalize - по сообщениям от опытных разрабов с Хабра - вещь, которую если надо применить - это признак code smell.
     Ключевое слово this: Известно, что в теле метода можно обращаться к другим членам класса, не указывая имя объекта класса. Допустим
     есть метод, возвращающий какое-либо значение: return value; value - возвращаемая переменная. Когда метод применится к объекту, он вернет
     это значение, кооторое установлено для этого объекта. return value; ожно переписать как return this.value; this говорит нам о том,
     что вернется value для конкретного объекта, т.е оно ссылается на этот объект. Конечно, в ключевом слове this нет необходимости
     в этой ситуации, так как метод и так вернет значения для объекта, для которого этот метод выполняется, но в ряде случае это
     ключевое слово может оказаться полезным. Основной случай - это при "скрытии" локальных переменных глобальными. Если глобальные
     переменные и локальные имеют одинаковые имена, то одни скроют другие, что ведет к неверно работающему коду, так как синтаксис
     Java позволяет это делать. СЛЕДУЕТ ПОМНИТЬ, ЧТО НЕВЕРНО РАБОТАЮЩИЙ КОД - ХУЖЕ ЧЕМ НЕРАБОТАЮЩИЙ!!!!!.
     Подобных вещей нужно избегать, но если есть необходимость, например, для удобства, можно использовать ключевое слово this
     для открытия локальных переменных, например, в кострукторах.
     Class (int a, double b){
     this.a = a;
     this.b = b;
     }
 Но все же, лучше не прибегать к такому стилю написания конструктора, да и вообще любых элементов, где подобная конструкция используется


     Структуры данных: данные в java хранятся в виде различных структур. простейшей такой структурой является массив. Массив
     это структура типа list(список), позволяющий получить произвольный доступ к его элементам.
     Но есть и другие виды структур. Структуры данных носят название коллекций(об этом позже в доп.литературе,
     в Шилдте 6-го издания про коллекции ничего нет(( )
     Массивы можно использвоать для формирования более сложных структур - стеков(stack) и очередей(queue). У стаков принцип
     LIFO - у очередей принцип FIFO(стеки и очереди это тоже списки). Особенности стеков и очередей в том, что доступ к данным поддерживается самой структурой,
     а не реализуется в программе. Такие сочетания реализуются в классах.
     1 коллекция: ОЧЕРЕДЬ!
     В очереди поддерживаются 2 основные операции размещение и извлечение. При размещении элемент помещаетсяч в конец,
     при извлечеии- извлекается первый элемент очереди.
     операции с очередью являются разрушающими - т.е элемент, однажды извлеченный, не может быть возвращен
     в очередь. Очередь может быть переполнена, а может быть и пуста.  Также очереди бывают циклические и нециклические.
     Циклическкая  очередь позволяет повторно использовать элементы массива, на основе которого создана по мере удаления данных.
     Нециклическая этого не позволяет, что со временем приводит к исчерпанию свободного пространства очереди. нециклическую чередь создать проще.
     Нециклическую очередь можно превратить в циклическую. При создании очереди на основе массива используется 2 параметра: 1 параметр отвечает за извлечение\
    элементов очереди, 2-й параметр - за вставку. Эти параметр называются индексами вставки и извлечения. Индекс вставки определяет
    в какое место будет помещен элемент в очереди, индекс извлечения - откуда извлечен. Операция извлечения - разрушающая,
    т.е не позволяет вывести элемент дважды. Создадим для примера очередь для хранения символов, но по тому же принципу
    можно хранить любые данные, в т.ч объекты! Делать это буду в отдельном классе Queue.
     разобрались, как работает очередь на примере, очередь может хранить разные типы данных в зависимости от того, какого
     типа переменная ch, т.к на нее ссылается метод получения значения очереди и к ней присваиваются элементы очереди.(логично)
     Размер очереди всегда на 1 элемент меньше размера массива, на основе которого создана, т.к монжо схлопотать ArrayIndexOutOfBoundsException(
    for-each - расширенный цикл for:
    Отличие от обычного for, данный цикл предназначен для работы с массивами. Выполняет очень важную функцию - обращается ко весм
    элементам массива одновременно. Изначально не был предусмотрен, был добавлен в JDK 5.
    Синтаксис:
    for (тип итр_пер : коллекция) {}
    Тип - тип данных ;итр_пер - итерационная переменная ;коллекция- набор данных с определенной структурой.
    С помощаю данного цикла, в итерационную переменную поочередно сохраняются элементы коллекции, например, массива. Каждый шаг
    цикла - это извлечение элемента коллекции и присваивания его к итерационной переменной. Выполнение цикла заканчивается тогда, когда все элементы коллекции
    будут извлечены. Т.е для массива[N] будет извлечены элементы от 0 до N-1.
    Логично, что тип переменной должен быть совместим с типом данных, содержащихся в коллекции.
    Отличия от бычного цикла for, почему возникла необходимость в расширенном:
    Для того чтобы обработать массив с помощью обычного цикла, нужно ввести локальную переменную, присвоить ей значение, указать
    шаг цикла, провести индексацию массива. А с помощью for-each, эта необходимость отпадает, упомянутые выше действия проводятся автоматически.
    Пример использования расширенного цикла for:
    int array[]={231,432,32423,646,214,46457,5234,4634};
    int sum=0;
    for(int x:array) sum+=x Сначала иксу присваивается 231 и прибавляется к сумме, затем 432, потом прибавление и т.д.
    Т.е обычный цикл for в расширенном варианте и более удобный для обработки массивов). С помощью for-each, можно обрабатывать
    любые коллекции, особенно удобен для обработки коллекций из Java Collections Framework.
    В данной разновидности цикла for, элементы автоматически извлекаются по мере роста индекса. С помощью break, можно завершить
    заранее, если указать условие завершения на каком-то конкретном значении массива(по индексу нельзя). Также, данный цикл предназначен
    только для чтения данных массива, но не позволяет записывать в него данные.
    Существует также особенность, которую нужно помнить при работе с многомерными массивами. Как мы знаем, многомерные массивы
    в Java - это массивы массивов, т.е индексам обратаываемого двумерного массива соответсвуют одномерные массивы, поэтому
    итерационная переменная будет одномерным массивом. прмиер на QueueUsing:
    Данный цикл, как кажется на первый взгляд, имеет ограниченное применение, так как просто перебирает элементы массива от
    нулевого индекса и до конца массива. Однако, с помощью этого цикла удобно искать значения в неотсортированных массивах, находить
    среднее значение элеметов массива, мин и макс значеия, дубликатов значений и т.д.
Объекты типа String
Строки - то, с чем работает повседневно любой программист. Строки в java реализованы в виде объектов. Объект типа String реали
зовывает содержимое строки и позволяет проводить над ней операции.
Пример объекта строки:String str = new String("В Java строки - это объекты.")
System.out.println(str). Результом, программа выведет значение объекта str, то есть надпись "В Java строки - это объекты."
Можно просто написать System.out.println("В Java строки - это объекты."). В таком случае, объект автоматом сгенерируется.
Класс String невероятно обширен, чтобы его полностью рассмотреть, необходима доп.литература, помимо Шилдта.
Как уже было показано выше, раз строки это объекты, то и создаются как все остальные объекты:
String str = new String("В Java строки - это объекты.") В данном случае создан объект str содержащий строку. В данном случае,
 как и в других объектах, str - это ссылка на строку.Также, объект можно создать без явного использования оператора new:
 String str = "В Java строки - это объекты.". Т.е, объект реализуется просто последовательностью символов, заключенных в
 двойные кавычки. Эта последовательность называется строковым литералом. Объекты строк могут быть переданы методам в качестве
 параметров, например методу print().
 Основные методы класса String:
 boolean equals() - сравниивает последовательность символов в строках, дает true при совпадении.
 int length() - лина строки.
 char charAt(index) - выводить символ строки с заданным индексом
 int compareTo(String str2) - возвращает отрицательное значение, если текущая строка меньши строки str2, 0 если равны,
 положительное если больше.
 int indexOf(String str) - выполняет в текущей строке поиск подстроки, определяемой параметорм str. Возвращает индекс
 первого вхождения подстроки str(индекс первого символа подстроки)
 -1, если поиск завершился неудачно
 int lastIndexOF (String str) - Производит в текущей строке поиск подстроки, опредляемой параметром str.  Возвращает индекс
 последнего вхождения подстроки str -1 если неудачный поиск.(индекс последнего сивола подстроки)
 Стоит отметить: метод equals сравнивает строки посимвольно, если сравнивать ссылки на строки с помощью ==, то
 проверяется только то, ссылаются ли ссылки на одну и ту же строку.
 Со объектами String можно проводить конкатенацию т.е сложение с помощью оператора +. Все примеры с комментами в QueueUsing
     Массивы строк
     Как и другие объекты и значения, можно объединять в массивы. для этого надо создать массив типа String: сделано в QueueUsing
     Объекты типа String являются неизменяемыми! Это значит, что состояние объекта не может быть изменено после его создания.
     Если требуется видоизменить строку, то создается новая строка с внесенными изменениями. Не стоит бояться по поводу
     забивки ОЗУ объектами строк, ведь неиспользуемые удалятся сборщиком мусора.
     Существуует мето substring(), который выделяет часть основной строки и преращает ее в новый объект. В методе указываются
     начальный и конечный индексы. Строка, к которй был применен метод, остается неизменной. Если необходимо изменить конкретную
     строку без создания нового объекта, то стандартная библиотека java предоставляет класс StringBuffer, в котором находится
     метод setCharAt(), вставляющий символ в строку. Но, как правило, функционала String достаточно.
     С помощью объектов класса String можно управлять оператором switch. В нашей Reference исправим константы на строки
     (не забудь!!!)(upd: не стоит лишний раз пользоваться строками в качестве констант, влияет на производительность, так как
     чтобы, сравнить 2 строки, требуется больше времени. Использовать, если это позволит создать более удобочитаемый и восприимчивый код).
     Использование аргументов командной строки:
     Многие программы получают параметры, задаваемые в командной строке, так называемые, аргументы командной строки.
     Чтобы получить доступ к этим аргументам, необходимо как раз обратитьься к массиву строк в начале выполняемой программы.
     Этими аргументами командной строки и является массив String args[]!! (наконец-то, узнали!!) Это нужно для работы с командной
     строкой, но не с IDE) При выполнении java-файла в командной строке, в командной строке могут прописываться параметры.
     Эти параметры заносятся в массив строк args[]. Бывает, когда программу удобнее запустить и работать с помощью командной строки,
     для этого используются специальные библиотеки разбора аргументов, такие как CommonsCLI и JCommander(после окончания курса,
     можно прочесть!)
Глава 6: Дополнительные сведения о классах и методах.
2 главных преимущества поодержки классом инкапсуляции: 1) данные класса связываются с кодом. 2) Обеспечивается овзможность
управления доступом к данным класса. В языке Java по сути есть 2 главных типа членов класса: public и private. Доступ к открытому
члену класса обеспечивается из люой точки программы, к закрытому только тем методам, которые определены в пределах класса.
С помощью закрытых членов и организуется управление доступом. Обеспечивание закрытости членов класса - основа инакпсуляции и
обязательный элемент ООП, так как это позволяет предотвратить неверное использование члена класса в программе. Для закрытого
члена класса нельзя задать значение непосредственно в коде, но в то же время можно управлять полностью тем, как и когда данные используются
в объекте. Следовательно, класс, в правильно написанной программе - это "черный ящик", который доступен для использования, но
его внутренне строение, механизм работы закрыты для доступа извне. По умолчанию, у нас использовался дефолтный модификатор,
предоставляющий доступ к членам класса любого класса из одного пакета. Это удобно для написания небольших, учебных программ, но
абсолютно недопустимо в реальных условиях, в реальных проектах.
Принцип инкапсуляции реализуется с помощью модификаторов доступа. в Java их 4:
 1) public - данный модификатор означает, что данным классом, методом можно воспользвоаться в любом месте нашей программы
 2) protected - методом или классом могут пользоваться все наследники. вне зависимости от того, в каком они пакете
  и классы с одного пакета
 3) private - доступ только внутри класса
 4) дефолтный модификатор - доступ внутри пакета, с других пакетов, в том числе наследникам, доступ запрещен. Он используется,
 если не указывается иной модификатор доступа.
 Рассмотрение FailSortArray: В классе имеется 3 закрытых члена класса: ссылка на массив а, переменная, сообщающая об ошибке
 errorvalue и метод indexOK, в котором определяется, находится ли индекс в пределах массива. Эти три члена могут быть использованы только
 членами класса FailSortArray. При создании объекта, мы указываем размер массива и значение переменной, сообщающей об ошибке,
 их мы передали конструктору в качестве аргументов. Так как и ссылка и переменная закрыты, исключена возможность видоизменения
 этих переменных извне. Доступ к указанным элементам возможен только с помощью методов get и put.
 1]Первый принцип ООП, который мы рассмотрим - это наследование. Очень удобная вещь, позволяющая
сэкономить кучу времени и сократить большое количество ненужного кода.
Допустим, наш класс оор содержит какие-то общие свойства
Теперь, нам надо создать класс, который обладает этими свойсвтами, но вдобавок имеет
какие-то свои собственные. Чтобы не приписывать общие свойства этому классу второй раз
и сущетсвует наследование. Все одинаковый свойства классов выделяются в отдельный класс,
который называют супер-классом, а классы, которые наследуются от него - подклассами.
Наследование применяет с помощью специального оператора extends. В нашем случае oopsecond
наследует от оор.
В Java может быть только один родительский класс. Потому что возникает проблема ромбовидного наследования.
Дерево наследований нельзя делать ниже 4-5 уровней.
2] Полиморфизм - очень мощное средство, достижение объектно-ориентированного программирования 1) Переопределение.
Если коротко, то в Java - это использование методов родительских классов объектами дочерних классов.
Примеры представлены с помощью классов оор и oopsecond в классе main.)
у нас есть метод getUran, который возвращает значение параметра uran для класса оор.
Но нам необходимо использовать этот метод в другом классе oopsecond, чтобы он выполнил ту же ф-b.
но выдал нужное нам значение для этого класса. Для этого мы ПЕРЕОПРЕДЕЛЯЕМ ЭТОМ МЕТОД В КЛАССЕ
oopsecond!!!! При переопределнии метода в другом классе лучше использовать аннотацию @Override
Аннотация нам сообщит, если вдруг у нас возникнет какая-нибудь ошибка при переопределнии
Далее, чтобы мы могли использовать переопределенный метод, объект создается в таком формате:
"класс с методом" "объект" = "new" "класс с переопределенным методом"*/
    /*Важно, чтобы классы были родственниками*/
/*Например: представим, что  у нас есть какая-то формула расчета, например, зарплаты для
 всех классов сотрудников. Но, какой-то из классов сотрудников должен получать зарплату по
 другой формуле расчета. В таком случае, применяя метод расчета зарплаты для этого особенного класса
 сотрудников, мы "переопределяем" метод расчета зарплаты , вводя в него ту формулу расчета,
 которая нам необходима для данного класса. В Java возможно перегружать все методы!!(кроме
 final) Если метод не был переопределен, то исполнится метод из родительского класса*
 Такая форма перегрузки методов с использвоанием родственных классом называется Overriding.
 Собственно, отсюда, аннотация @Override
 Этот способ особенно удобен, когда происходит работа с целыми массивами объектов(массив-это тоже объект в java)))
 когда, из 100 объектов, к 99 применяется метод по одной формуле, а к 100 нужна другая формула
 2) Перегрузка: Несколько методов одного и того же класса могут иметь разные имена, но выполнять схожий функционал и
 отличаясь лишь набором праметров. Для того, чтобы перегрузить метод, необходимо просто объявить его новый вариант, а остальное
 сделает компилятор. нужно соблюсти обязательное условие: тип и/или число параметров в перегружаемых методах должно быть разным.
 Одной лишь разницы в типах возвращаемых значений недостаточно, так как не будет хватать информации о том, какой метод
 использовать. Пример:
 public void myMeth1(){System.out.println("The basic variant of the method")};
 public void myMeth1(int a){{System.out.println("Overload number 1")};
 public int myMeth1(int a,b){{System.out.println("Overload number 2");return a+b;};
 public double myMeth1(double a,b)(System.out.println("Overload number 3");return a+b;);
 Соответственно, будет вызыватся тот метод, в зависимости от того, что мы ему передадим в качестве аргументов, например:
 someClass someobj = new someClass();
 someobj.myMeth1();  //Здесь вызовется первоначальнач версия метода myMeth1, так как нет никаких параемтров
 someobj.myMeth1(2.3,5.3);//Здесь вызвется четвертая версия метода, так как аргументы, переданные методу типа double
 Важно знать, что в перегружаемых методах, переменные типа byte short автоматически преобразуются в int, float в double.
 в том случае, если нет прямого сходства. Например, метод abs() из класса Math автоматом перегружается, исходя из типа
 переданных аргументов. Перегружать можно только сильно взаимосвязанные между собой методы, выполняющие одну и ту же ф-ию
 с разными типами данных!!!
 Рекурсия: Рекурсия в программировании - это когда метод вызывает сам себя. В таком случае метод называют рекурсивным.
 При использовании рекурсивных методов нужно смотреть, чтобы в программе был оператор if для выхода из рекурсивного метода
 без выполнения рекурсивного вызова. Иначе метод никогда не выполнит возврат. Рекурсия очень ресурсоемкий прием, так как
 для каждого самовызова метода, в стеке выделяется место для значений переменных с каждого вызова. По возможности, лучше
 не применять в целях недопущения потери в производительности.
 Кейворд static: с помощью данного ключевого слова, мы избавляемся от необходимости создания объекта для использования
 члена класса. Ставится перед типом члена класса и после модификатора доступа. Если член класса static, то он становится доступным
 до создания объекта своего класса и без ссылки на какой-либо объект. С помощью слова static можно объявлять переменные и методы.
 Такие переменные и методы называют статическими. По сути, член класса типа static становится доступным при вызове не с помощью
 объекта, а с помощью класса, в котором объявлен. Пример в QueueUsing. Статические переменные - глобальные. При создании объекта
 копии статитческих переменных в них не создаются, они сразу используются одну и ту же копию статической переменной, объявленной
 непосредственно в классе как static. Важный момент(и логичный) - изменения в статической переменной - изменение значения
 в масштабах всего класса, а не только конкретного экземпляра класса.
 Ограничения статических методов:
 1)В статическом методе допускается непосредственный вызов только других статических методов.
 2)Для метода типа static непосредственно доступны только другие данные типа static.
 3) В методах static должна отсутствовать ссылка this.
 Абстрактные классы: По сути, часто втречаются ситуации, когда мы не можем для нашего удобства, или же по каким-то другим причинам,
 полностью описать метод в суперклассе. Часто встречаются случаи, когда нам просто нужно создать в суперклассе метод, который
 бы был создан с целью переопределения в классах-наследниках. Т.е, невозможно дать определние метода в контексте его суперкласса.
 Есть 2 выхода из этой ситуации: 1-й это вывести предупреждающее сообщение, которое бы нас уведомляло о том, что метод, для
 его  применения к каким-либо объектам каких -либо классов должен быть переопредлен. Но это неудобно, непрактично. И не используется
 в реальных проектах. 2-й: это использвоание абстракного метода! Это единственный используемый на практике вариант!
 Этот способ гарантирует, что все необходимые, определнные в суперклассе методы, будут переопределны.
 Абстрактный метод объявляется с помощью ключевого слова abstract. Общий синтаксис:
 abstract тип имя_метода(список_параметров);
 Абстрактный метод не имеет тела, поэтому не реализуется в суперклассе. это означает, что метод должен быть переопределен в суперклассе,
 так как его изначальный вариант просто непригоден для использования. В классе-наследнике абстракного клдасса должны быть
 переопределны все методы, прописанные в абстрактном классе. В абстракном классе могут находиться и конктренто сформулированные
 методы, только те методы должны быть обязательно переопределны, которые обозначаются ключевым словом abstract.
 Ключевое слово final: final запрещает переопределять метод и наследоваться от класса. Скорее всего, это необходимо, в целях
 безопасности. Если final применяется к классу, то применяется и ко всем методам класса. Логично, нет смысла применять final
 к абстрактным классам и методам, так как они должны быть наследованы/переопределны соответственно.
  final может применяться к переменным. В таком случае, переменная станет константой, и не будет меняться на протяжении
  всего времени выполнения программы. Очевидно, переменные должны иметь начальные значения. Многие программисты обозначают
  константы final полностью заглавными буквами, типа:
  final int CONSTFINAL = 100; просто общепринятый стиль. Переменная типа final может быть static, следовательно нет необходимости
  создания экземляра класса для работы с данной переменной
  Класс Object; !!!!!!!!!!!!!!!!!!!!!!!СВЯТАЯ СВЯТЫХ О ВЕЛИКОЙ JAVA!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!КЛАСС OBJECT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Данный класс является суперклассом всех остальных классов. Это означает, что ссылочная переменная Object может ссылаться
на объект любого класса . Входит в java.lang. В том числе, может ссылаться на строковые объекты и на массивы
Класс включает в себя следующие методы:
Object clone() - создает клон объекта
boolean equals(Object someobj) - проверяет равнозначность объектов
void finalize() - метод finalize, прошли ранее, бесполезен
int hashcode - возвращает хеш-код объекта
void notify - возобновляет работу потока, ожидающего уведомления от вызывающего объекта
void notifyAll - возобновляет работу всех потоков, ожидающих уведомления от вызывающего объекта
String toString - возвращает строку, описывающую объект(путь класса и номер объекта в памяти в 16-й системе счисления)
void wait() - ожидает исполнения другого потока
Class<?>getClass() - определяет класс объекта во время выполнения P.S используется обобщение, об этом позже.
Оператор instanceof - оператор типа boolean, возвращающий true в том случае, когда объект, к которому был применен оператор принадле-
жит к классу, к к которому был применен. Общий синтаксис:
if(someObj instanceof someClass) return someValue;
Если объект someObj принадлежит классу someClass, то вернется значение true и будет возвращено значение someValue. Как правило,
применяется вместе с оператором if. Если someClass это интерфейс, и объект принадлежит к классу, реализующему этот интерфейс, также
будет возвращено true. Либо если someObj объект класса-наследника someClass, т.е someClass - это суперкласс, также будет возвращено
true. instanceof помогает упорядочить логику кода в некоторых случаях, используется при Android-разработке.
Обработка Исключений:
Исключительные ситуации, или исключения -  это ошибки, возникаемые в процессе выполнения программы. По англ. Exceptions.
В Java существует система обработки исключений, которая позволяет реализовать реакцию программы на те или иные исключения.
Преимущества этой системы заключаются в том, что она позволяет автоматически реагировать на такие ситуации, избавляя от необходимости
писать соответсвующий код вручную. любая программа предусматривает БЛОК ОБРАБОТКИ ИСКЛЮЧЕНИЙ, который выполняется при
бросании исключений. Это избавляет от необходимости вручную проверять, правильно ли выполнилась та или иная операция
или вызов метода. Если возникнет ошибка, то обработчик автоматически проведет необходимые операции. В Java API редусмотрены
стандартные исключения. Например, при делении на 0, компилятор бросает исключение ArithmeticException. Это исключение входит в пакет java.lang.
Чтобы успешно программировать, необходимо уметь обрабатывать исключения!!!
Иерархия исключений: Основной класс исключений в java - класс Throwable. Если возникнет ошибка, будет сгенерирован объект
определенного класса исключения. У класса Throwable имеется 2 подкласса: Error и Exception. Все остальные классы обработки
исключений наследуются от этих 2-х классов. Исключения класса Error - это ошибки виртуальной машины Java ,их появление не
зависит от выполнения прикладной программы, и реакция на них в программе, как правило, не предусматривается. А вот исключения
класса Exception - это уже исключения, возникающие в работе программы. Самым важным производным от Exception является
RuntimeException, который содержит основные исключения, которые чаще всего вызываются.
Условия, в которых генерируются исключения: необходимо выполнение одного из 3-х условий: 1)Исключение может быть сгенерировано
JVM на некоторую внутреннюю ошибку. 2) Ошибка в коде программы, при которых выбрасываются стандартные исключения, подлежащие
обработке. 3) Вручную сгенерированное с помощью ключевого слова throw. Порядок обработки исключений не зависит от того, как именно
они были сгенерированы(имеется в виду, каким из способов)
Ключевые слова для обработки исключений: их 5: try, catch, throw,throws, finally.
Магия исключений(т.е поведение, никак не отраженное в коде программы и не выполняемое пользователем): ключевые слова
catch, throw,throws можно использовать только для работы с Throwable и его наследниками.
Как правило, при обработке исключений в одной программе, используются все 5 слов, одно влечет за собой использование другого.
Операторы, в которых требуется отслеживать появление исключений, помещаются в блок try, з которого потом их можно перехватить
и обработать нужным образом. Системные исключение генерируются автоматом. Чтобы бросить исключение вручную, используется
ключевое слово throw. Иногда возникает потребность обрабатывать исключения за пределами метода, в котором выполняется
обрабатываемый код. Для этого необходимо воспользоваться ключевым словом throws. Код, в котором в любом случае должен быть
выполнен код блока try помещается в блок finally.
try и catch - основные средства обработки исключений в java. они используются совместно. Общий синтаксис конструкции try/catch:
try{ // Блок кода, в котором должны отслеживаться ошибки
}
catch(тип_исключения_1 объект_исключения){
// обработчик исключения
}
catch(тип_исключения_2 объект_исключения){
//обработчик исключения
}
.
.
.
В скобках опреатора catch указывается тип исключения и ссылка на объект данного типа. Когда возникает исключение в блоке try,
блок catch перехватывает это исключение и обрабатывает его. С одним блоком try м/б связано несколько операторов catch .
Тип исключения определяет, какой блок catch будет вызван. Остальные блоки catch будут пропущены. При перехвате исключения,
переменной присваивается ссылка на объект исключения. Пример обработки ArithmeticException с помощью try/catch в FSADemo.
Если исключение не генерируется, то try завершается обычным образом без вызова catch. Также, с помощью try/catch обрабатываются
методы, и catch также будет обрабатывать исключения, но только в том случае, если метод сам их не обрабатывает. Т.е если метод
не обрабатывает исключение, то он передает его методу main, который уже его обрабатывает, если метод main содержит конструкцию
try/catch. Если метод сам обрабатывает, то исключение вообще не дойдет до метода main.
Необработанные исключения:
Если исключения не обрабатывать, то их обработкой займется JVM. Это не есть гуд! Вернее, это хорошо только для разработчика,
так как сообщения выдаваемые JVM полезны для отладки программы, но для пользователя это создаст проблемы. Так как при генерации
исключения, программа аварийно завершается по умолчанию. Поэтому важно, чтобы исключения обрабатывались разработчиком, а не
JVM. Тип обрабатываемого исключения должен соответствовать типу, прописанному в операторе catch. В противном случае, обработка
не будет работать. Так что, обрабатывайте ошибки правильно, господа!
Главное преимущество обработки исключений заключается в том, что это позволяет овремя отреагировать на ошибку и предотватить
аварийное завершение программы. Т.е, при выбросе исключения и его обработке, программа далее продолжает свою работу, выполнив
код, прописанный в блоке catch. Обработанное исключение удаляется из системы, поэтому может быть повторно обработано, если оно возникнет
Пример в DynQueueUsing . Так пример множественной конструкции операторов catch.
Перехват исключений , генерируемых подклассами: в случае использования множествнных операторов catch, исключения, перехватываемые\
суперклассами перехватываются и для подклассов. Например, класс Throwable является супер-классмо для всех обрабатываемых классов исключений
поэтому для перехвата всех исключений в операторах catch достаточно указать тип Throwable. Если же требуется перехватывать
исключения подклассов и суперклассов, первым должен перехватываться подкласс. В противном случае, вместе с суперклассом будут
перехвачены все исключения всех его подклассов. Если сначала указать исключение суперкласса, а затем подкласса, это приведет
к созданию недостижимого кода. Т.е, сначала обрабатываем подкласс, затем, если надо суперкласс. Вывод: порядок следования
оператторов catch особо важен. Бывает возникает необходимость перехвата исключений в суперклассах, когда для обработки
исключений семейства классов подходит единый алгоритм, что поможет избежать дублирования кода. Также, если необходимо
предотварить аварийное завершение прораммы, вне зависимости от типа ошибки. Это и было предусмотрено разработчиками языка.
Вложенные блоки try: в один блок try можно вложить другой: если исключение не будет перехвачено внутренним блоком, его пере-
хватом займется внешний блок. Пример в DynQueueUsing.
Вложенные блоки try помогают по разному обрабатывать исключения. Одни ошибки невозможно устранить, а для других достаточно предусмотреть простые действия
Внешний блок try применяется для обработки критических ошибок, а внутренний - для перехвата мелких, незначительных.
Генерирование исключений:
Исклчение генериурются автоматически виртуальной машиной Java. Но можно сгенерировать самим: для этого используем throw:
Синтаксис: throw объект_исключения. Объект_исключения д/б производным от Throwable.
Пример в dynQueueUsing:
Перед именем объекта исключения нужен оператор new после throw, так как генерируется новый объект(исключения - объекты, не забываем)
При повторном генерировании исключений, это исключение не может быть перехвачено тем же самым блоком catch, оно распростаняется
на следующий блок. Самый логичный вопрос, возникающий в ходе разбора этой темы: ЗАЧЕМ ГЕНЕРИРОВАТЬ ОШИБКИ ВРУЧНУЮ???????
Ответ:) - Далее поймем
Класс Throwable: Исключения можно не только перехватывать, но и проводить с ними действия, с помощью методов, прописанных
в классе Throwable. При перехвате исключения в операторе catch также прописывается ссылка, которой будет присвоен объект исключения.
Все исключения являются поклассами Throwable, следовательно можно использовать методы этого класса со всеми объектами исключений.
Наиболее востребованные методы класса Throwable:
1)Throwable fillInStackTrace() - Возвращает объект типа Throwable, содержащий полную трассировку стека исключений. Этот объект
пригоден для повторной генерации исключений. Трассировка стека - список вызовов методов для данной точки программы.
2)String getLocalizedMessage() - озвращает описание исключения, локализированное по региональным стандартам
3)String getMessage() - возвращает описание исключения.
4)void printStackTrace() - выводит трассировку стека исключений
5)void printStackTrace(PrintStream поток) - возвращает трассировку стека в указанный поток
6)void PrintStackTrace(PrintWriter поток) - направляет трассировку стека исключений в указанный поток
7)String toString - возвращает объект типа String одержащий полное описание исключения. Этот метод вызвается из метода println()
при выводе объекта Throwable.
С помощью метода printStackTrace() можно вывести стандарное сообщение об ошибке и запись последорвательности вызовов методов,
которые привели к возникновению ошибки. А метод toString позволяет получить стандартное сообщение об ошибке. Этот метод также
вызывается в том случае, когда объект исклюбчения передается методу println().  По сути, printStackTrace выводит стандартное сообщение
об обишке, которое выводит JVM.
Слово finally: Допустим, в программе возникла ошибка, требующая ее завершение, но вдруг открыты файлы, или установлено содеинение?
Значит нужно файлы закрыть, а соединение разорвать. Для этого и существует finally! finally прописывается после блока try и
означает, что после завершения блока try, блок кода в finally должен быть обязателньо выполнен! Вне зависимости от того,
перехвачено ли было исключение в блоке try или нет. Даже если выйти из блока try  помощью return, finally все равно будет выполнен.
Слово throws: Часто, исключения нецелесообразно(на практике так и есть) обрабатывать внутри методов, в которых они возникают.
В таком случае, эти методы следует указывать с помощью слова throws:
напримеер: public static int Method() throws ArrayIndexOutOfBoudsException, ArithmeticException{}
По умолчанию, исключения классов Error и RuntimeException включены в систему обработки. Поэтому нет нужды указывать их
с помощью throws, компилятор и так знает, что методы могут их генерировать. Отсальные же классы исключений нужно укзаывать с
помощью ключевого слова throws. Например, при вводе с клавиатуры, необходимо указывать в методе, что он может бросить
java.io.IOException .
Групповой перехват исключений:
catch(ArrayIndexOutOfBoundsException | ArithmeticException ) - таким образом catch перехватывает сразу 2 исключения.
Параметры в операторе catch неявно указываются как final, можно и явно указать, нео это необязательно.
Это нужно для того, если в операторе catch выполняется один  и тот же код, но перехватываются несколько исключений
Встроенные классы Исключений:
Стандартные классы исключений входят в пакет java.lang(поэтому их и не нужно импортировать).
Эти исключения называются непроверяемыми, так как компилятор не обязывает вводить проверку для этих исключений. Но есть некоторые
которые обязательно нужно указывать с помощью оператора throws. Эти исключения называются проверяемыми.
Непроверяемые исключения пакета java.lang: //некоторые нельзя увидеть, IntellijIdea сама походу обрабатывает их(так и есть)
1)ArithmeticException - арифметическая ошибка(деление на ноль)
2)ArrayIndexOutOfBoundsException - выход за границы массива
3)ArrayStoreException - Попытка ввести элемент в массив, неподходящий типу массива
4)ClassCastException - недопустимое приведение типов
5)EnumConstNotPresentException - попытка использования нумерованного значения, которое не было приведено ранее
6)IllegalArgumentException - недопустимый аргумент при вызове метода
7)IllegalMonitorStateException - Недопустимая операция контроля, например, ожидание разблокировки потока
8)IllegalStateException - недопустимое состояние среды или приложения
9)IllegalThreadStateException - Запрашиваемая операция несовместима с текущим состоянием потока
10)IndexOutOfBoundsException - недопустимый индекс
11)NegativeArraySizeException - создание массива отрицательного размера
12)NullPointerException(в народе NPE) - использование пустой ссылки - #супервреднаягадость
13)NumberFormatException - неверное преобразование символьной строки в число
14)SecurityException - попытка нарушить систему безопасности
15)StringIndexOutOfBounds - попытка обратиться за границы строки
16)TypeNotPresentException - несуществующий тип
17)UnsupportedOperationException - Неподдерживаемая операция
Проверяемые исключения:
ClassNotFoundException - класс не найден
CloneNotSupportedException - попытка клонирования объекта, не реализующего интерфейс Clone
IllegalAccessException - доступ к классу запрещен
InstantiationException - Попытка создания объекта абстрактного класса или интерфейса
InterruptedException - Прерывание одного потока другим
NoSuchFieldException - требуемое поле не существует
NoSuchMethodException - требуемый метод не существует
ReflectiveOperationException - суперкласс исключений, связанных с рефлексией
Цепочечные исключения - это исключение, результатом появления которого является появление другого исключения
Когда следует обрабатывать ошибки: обработчик ошибок должен присутсвовать всегда

ВВОД-ВЫВОД ДАННЫХ:
Все ниже перечисленные примеры ввода-вывода данных относятся к консольному и файловому вводу-выводу. К графическому применяются другие методы
Операции ввода-вывода в Java основаны на потоках! Поток - абстрактная сущность, представляющая устройства ввода-вывода, которое
выдает и получает информацию. За связь с физическими устройствами ввода-вывода отвечает система ввода-вывода, так что это
позволяет использовать одни и те же методы ввода-вывода с разными физическими устройствами. Для реализации потоков используется
иерархия классов, определенная в пакете java.io.(java.io отвечает за ввод-вывод данных, в принципе).
В Java определено 2 типа потоков - байтовые и символьные. Байтовые потоки предоставляют инструменты для ввода-вывода байтовых
значений, например, для чтения и записи двоичных чисел. Эти потоки удобны при работе с файлами. Однако, символьные потоки, в некоторых
случаях являются более эффективными, по сравнению с байтовыми. Символьные потоки  ориетировны на обмен символьными данными в
кодировке Unicode. В java.io 2 иерархии классов: одна для байтовых, другая для символьных потоков. В большинстве случаев, возможности
символьных потоков повторяют возможности байтовых. На самом нижнем уровне, средства ввода-вывода имеют байтовую организацию.
Классы байтовых потоков: байтовая иерархия определена двумя суперклассами, которые являются абстрактными: InputStream и
OutputStream. Производные этих классов - классы, выполняющие конкретные функциональные возможности и учитывающие особенности
обмена данными с различными физическими устройствами.
Классы байтового потока:
BufferedInputStream - буферизованный входной поток
BufferedOutputStream - буферизованных выходной поток
ByteArrayInputStream - поток для чтения из байтового массива
ByteArrayOutputStream - поток для записи в байтовый массив
DataInputStream - входной поток , включающий методы для чтения стандартных типов данных в Java
DataOutputStream - выходной поток , включающий методы для записи стандартных типов данных
FileInputStream - входной поток для чтения из файла
FileOutputStream  - выходной поток для записи в файл
FilterInputStream - реализация класса InputStream
FilterOutputStream - реализация класса OutputStream
InputStream - абстрактный класс, описывающий входной поток
ObjectInputStream - входной поток для объектов
ObjectOutputStream - выходной поток для объектов
OutputStream - абстрактный класс, описывающий выходной поток
PipedInputStream - входной канал
PipedOutputStream  - выходной канал
PrintStream - выходной поток, включающий методы print() и println()
PushbackInputStream - входной поток, позволяющий возвращать байты обратно в поток
SequenceInputStream - Входной поток, включающий в себя несколько поток, которые читаются последовательно, один после другого
Классы символьного потока:
Символьный поток определен также 2-мя иерархиями классов: Writer и Reader. Класс Reader и его производные - это чтение данных
Writer и производные - запись файлов. В целом, символьные классы имеют схожий функционал с байтовыми:
BufferedReader - буферизованный входной символьный поток
BufferedWriter - буферизованный выходной символьный поток
CharArrayReader - входной поток для чтения из символьного массива
CharArrayWriter - выходной поток для записи в символьный массив
FileReader - входной поток для чтения из файла
FileWriter - выходной для записи в файл
FilterReader - фильтрующий входной поток
FilterWriter - фильтрующий выходной поток
InputStreamReader - Входной поток, транслирующий байты в символы
OutputStreamWriter - выходной поток, транслирцющи символы в байты
LineNumberReader - Входной поток, подсчитывающий строки
PipedWriter - Выходной канал
PipedReader - входной канал
PrintWriter - Выходной поток, включающий методы print() и println()
PushbackReader - входной поток озвращающий символы обратно в поток
Reader{Абстрактные классы,описывающие
Writer    символьные ввод и вывод соответственно}
StringReader-Входной поток для чтения из строки
StringWriter Выходной поток для записи в строку
Вот основные подклассы потоков

Встроенные потоки: в пакете java.lang определен класс System. Он инкапсулирует некоторые свойства среды выполнения. В данном
классе содержатся преопределенные переменные in, out, err. Эти переменные представляют стандртные потоки ввода-вывода. Эти
поля объявлены как public static final, т.е к ним можно ссылаться, не ссылаясь на объект типа System.
System.out - ссылка на стандартный выходной поток, по умолчанию связанный с консолью. System.in - стандартный входной поток,
по умолчанию связанный с клавиатурой. System.err - стандартный выходной поток ошибок, связанный с консолью. при необходимости
каждый из этих потоков может быть перенаправлен на любое другое устройство. System.in - объект типа InputStream
System.out System.err - объекты типа PrintStream. Все эти потоки байтовые, хотя используются для чтения и записи символов в консоль
 и из консоли.
 Методы, определенные в классах InputStream и OutputStream:
 1)InputStream:
 int available() - возвращает кол-во байтов ввода, доступных для чтения в данный момент
 void close() - закрывает источник ввода. Дальнейшие попытки чтения будут генерирвоать IOException
 void mark(int numBytes) - помещает метку в текущую позицию входного потока, пока не будет прочитано кол-во байт, определенное
 параметром numBytes
 boolean markSupported() - вовзвращает true, если mark() и reset() поддерживаются вызывающим потоком
 int read() - вовзращает целочисленное значение следующего байта в потоке. при достижении конца потока вовзращает -1
 int read(byte buffer[]) - пытается прочитать buffer.length байтов в массив buffer, возвращая фактическое количество прочитанных
 байтов. При достижении конца потока вызвает -1.
 int read(byte buffer[], int offset, int numBytes) - Птыается прочитать numBytes байтов в массив buffer, начиная с элемента
 buffer[offset] и возвращает фактическое количество прочитанных байтов. При достижении конца потока возвращает -1
 void reset() - сбрасывает входной указатель на ранее установленную метку
 long skip(long numBytes) - пропускает numBytes входных байтов, возвращая фактическое количество пропущенных байтов.
 2)OutputStream
 void close()- закрывает выходной поток. Дальнейшие попытки записи генерируют IOException
 void flush()-Выполнеяет принудительную передачу содержимого выходного буфера в точку назначения(тем самым очищается выходной буфер)
 void write(int b) - записывает 1 байт в выходной поток. Так как параметр имеет тип int, не нужно приводить к byte.
 void write(byte buffer[]) - записывает полный массив байтов в выходной поток
 void write(byte buffer[], int offset, int numBytes) - записывает часть массива buffer количеством numBytes начиная с buffer[offset]
 Поток System.in - экземпляр класса InputStream,  а следовательно имеет доступ ко всем методам этого класса. Для чтения байтов
 предусмотрен только метод read(его и использовали ранее). Признак достижения конца потока System.in определяется с помощью клавиши
 Enter. В зависимости  от того, нужно ли нам ввести один символ или же несколько, используем разные формы метода read.
 Все формы метода read могут генерировать IOException, поэтому важно указывать, что они могут бросать это исключение.
 Ввод-вывод практикуем в классе IOtrying;
Запись консольного вывода:
Стандартный поток вывода System.out - байтовый, он по-прежнему используется для вывода побайтово данных на консоль.
Вывод на консоль осуществляется с помощью уже занкомых методов print() и println(). Эти элменты определны в классе PrintStream.
Поток PrintStream наследуется от OutputStream, следовательно реализует методы OutputStream, такие как write():
анный метод, несмотря на то, что имеет параметр типа int, в нем учитываются только младшие 8 бит. Данный метод, конечно, менее
удобен, чем print() и println(), учше вместо метода write использовать эти методы. В классе PrintStream реализованы методы
printf() и format(), оторые позволяют управлять форматированием вводимых данных. Например, указать ширину поля, способ представления
отрицательных чисел, количество десятичных цифр.

Файловые операции ввода-вывода: Реализуются с помощью потоков FileInputStream и FileOutputStream. В Java файлы имеют побайтовую
организацию, для работы с которой предусмотрены ссответствующие методы. Допускается создавать оболочки в виде символьных объектов
Для работы с этим потокм, нужно передать конструктору этого класса имя файла.
FileInputStream(String имя_файла) throws FileNotFoundException;
Если файл не найден, бросается соответсвующее исключение. Для чтения данных из файла исп. метод read(). Завершив операции с файлом
, его нужно закрыть с помощью close(), дабы освободить системные ресурсы. Если этого не сделать, то возможна утечка памяти.
Запись в файл:
Создается объект FileOutputStream. 2 конструктора:
FileOutputStream(String имя_файла) throws FileNotFoundException
FileOutputStream(String имя_файла, boolean append) throws FileNotFoundException
Параметр append: если принимает истинное значение, то записываемые данные добавляются в конец файла. В противном случае, старые
данные перезаписываются новыми.
Для записи в файл применяется метод:
write(int byteval) throws IOexception;
Метод записывает в поток значение byteval. В случае ошибки, генерирует IOException
byteval объявлен как int, но учитываются только младшие 8 бит.
По окончании рабоыт с файлом, его нужно закрыть с помощью close();
void close() throws IOException;
Оператор try с ресурсами: данная фича добавлена в JDK7
Другое название - автоматическое управление ресурсами.
Синтаксис:
try(описание_ресурса) {
//использование ресурса
}
Описание ресурса - это объявление и инициализация ресурса, например файла. По сути, это объявление переменной, которая
инициализируется ссылкой на объект управляемого ресурса. По завершении блока try с ресурсами, ресурс автоматически закрывается.
То есть, не нужно явным образом каждый раз вызывать метод close().
Try с ресурсами управляет только теми реурсами, которые реализуют интерфейс AutoClosable с пакета
java.lang.  Этот интерфейс наследуется от интерфейса Closable с пакета java.io. Оба интерфейса реализуются классами потоков,
в том числе FileInputStream и FileOutputStream. Модернизировал 4-ю прогу, убрал блок finally , который
включал в себя метод close() для входного и выходного потоков и заменил его оператором try с ресурсами. данный оператор
может обрабатывать несколько ресурсов, для этого в описании ресурсов их нужно разделять точкой с запятой.
Чтение и запись двоичных данных:
Помимо чтения и записи байтовых данных, представленных в кодировке ASCII, можно записывать и считывать другие типы данных,
int, short, double и т.д. Для чтения и записи простых типов данных предусмотрены классы DataInputStream и DataOutputStream.
DataOutputStream реализует интерфейс DataOutput, следовательно ему доступны методы этого интерфейса, позволяющие записывать
данные в файл любых примитивных типов.
Главная особенность: данные записываются во внутреннем двоичном формате, а не в виде последовательности символов.
Каждый из этих методов может генерировать IOException
1)void writeBoolean(boolean val) - записывает значение типа boolean, определенное параметром val
2)void writeByte(int val) - записывает младший байт значения
3)void writeChar(int val) - записывает значение в виде символа
4)void writeDouble(double val) - записывает значение типа double
5)void writeFloat(float val) - тип float
6)void writeInt(int val) - тип int
7)void writeLong(long val) - тип long
8)void writeShort(int val) - младшие 2 байта значения val
При создании объекта DataOutputStream его конструктору передается объект класса OutputStream(т.е выходной поток, в который идет
запись данных)
Для того, чтобы записывать в файл, нужно передать конструктору объект класса FileOutputStream
В потоке DataInputStream чтение данных производится также в двоичном формате. При создании объекта этого класса, его конструктору
передается объект InputStream или, если чтение с файла, FileInputStream. DataInputStream реализует DataInput интерфейс, предоставляющий
все методы для работы с примитивами.
Методы чтения разных типов данных:
boolean readBoolean();
byte readByte();
int readInt();
char readChar();
double readDouble();
float readFloat();
long readLong();
short readShort();
Файлы с произвольным доступом:
Ранее, производилось чтение и запись побайтово срого по порядку. для произвольного доступа к файлам, испольузется класс
RandomAccessFile.
Конструктор класса:
RandomAccessFile(String имя_файла, String доступ) throws FileNotFoundException:
Виды доступа: r - только чтение, rw - чтение и запись.
Используется метод seek, устанавливающий указатель текущего положения:
void seek(long новая_позиция) throws IOException
Новая позиция - положение указателя в байтах относительно начала файла. Данный класс реализует интерфейсы DataInput и DataOutput
следовательно может работать с примитивами. В зависимости от того, сколько байт требуется на то или иное значение, можно получать
разные записанныев файл значения, ссылаясь на границу значений в байтах. Например, записано 4 значения типа int. На один int
нуужно 4 байта, следовательно для получения доступа к первому значению, в методе seek нужно задать параметр 0(первый байт),
второму - 4(пятый байт, с него начинается второе значение) и т.д.

СИМВОЛЬНЫЕ ПОТОКИ:
Используются для ввода-вывода символов.
Консольный ввод: поток System.in - байтовый, поэтому его нужно преобразовать в символьный для работы с потоком символов.
Для этого используется класс BufferedReader, содержащий буферизованный входной поток. Он будет являться оболочкой для нашего
преобразуемого байтового потока. Поток System.in преобразуется с помощью класса InputStreamReader: экземпляр данного
класса (в нашем случае System.in)передается классу BufferedReader в качестве параметра, следовательно экземпляр класса
BufferedReader будет содержать ссылку на поток System.in связанный с клавиатурой.
Для чтения строк, используется метод readLine() типа String.
Использование классов оболочек для преобразования числовых строк:
В Java имеются оболочки типов. Это примитивные типы, реализованные в виде объектов. Например, простой тип нельзя передать
методу по ссылке. Объектные оболочки предусмотрены для каждого примитивного типа
Классы примитивных оболочек: Byte, Boolean, Double, Float, Integer, Character, Long, Short. Названия соответсвуют типам.
За исключением того, что классы начинаются с заглавной буквы. Эти классы позволяют интегрировать простые типы в иерархию объектов
Коллекции взаимодействуют только с объектами данных. метод parseТип, где тип - это название класса-оболочки, позволяющий преобразовать
строку в значение соответствующего типа.
(Новая инфа не с книги)
Инициализаторы классов: инициализаторы классов - это блоки кода, помеченные модификатором static. Синтаксис:
static {блок_кода}.
При запуске класса, происходит выполнение этих блоков-инициализаторов в том порядке, в котором они определены.
Эти блоки вызываются ТОЛЬКО 1 РАЗ ДО вызова конструктора или ОСНОВНОГО МЕТОДА. Данные блоки
прописываются перед методом main. Такие же блоки, но без модификатора static называются инициализаторами экземляра. данные
блоки выполняются при создании экземляра класса до вызова конструктора.







*/

}
