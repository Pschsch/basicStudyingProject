package com.maxonchik.OOP;
/******************************Класс с подробной информацией о пакете java.lang.*****************************************************/
/*Поехали) начинаем изучать стандартную Java библиотеку
* Этот пакет автоматически импортируется во все программы на Java, поскольку составляет ее основу. Нет java.lang - нет Java.
* Это как мозг и человек. Все классы, определнные в этом пакете, в той или иной степени используются во всех программах на Java.
* Этот пакет нужно знать на зубок!
* **********************************************************************************************************************************
* Список классов, предоставляемых пакетом java.lang:
* Boolean  Byte  Character  Character.Subset  Character.UnicodeBlock  Class  ClassLoader  ClassValue  Compiler  Double  Enum
* Float  InheritableThreadLocal  Integer  Long  Math  Number  Object  Package  Process  ProcessBuilder  ProcessBuilder.Redirect
* Runtime  RuntimePermission  SecurityManager  Short  StackTraceElement StrictMath  String StringBuilder  StringBuffer  System
* Thread  ThreadGroup  ThreadLocal  Throwable  Void
* **********************************************************************************************************************************
* Список интерфейсов:
* Appendable  Cloneable  Readable  AutoCloseable  Comparable  Runnable  CharSequence  Iterable  Thread.UncaughtExceptionHandler
* **********************************************************************************************************************************
* Данный пакет содержит большое количество deprecated методов, так как все еще проиводится поддержка устраревшего кода.
* Оболочки примитивных типов: основной функционал оболочек мы знаем, есть более подробное рассмотрение:
* 1-й класс: Number - абстрактный класс, имплементирующий интерфейс Serializable. Это супер-класс для числовых классов-оболочек.
* Его методы также уже знаем, это методы возврата числовых значений: byteValue(), intValue() и т.д.
* 2-й и 3-й класс: Double и Float - оболочки для чисел с плавающей точкой. Объект Float ожет быть создан как из double, так из float.
* в то время, как Double может быть создан только из double. Создание объектов Float и Double из строковых представлений бросают
* NumberFormatException в случае несоответствия типов.
* Константы класса Float и Double:
* Можно посмотреть в исходнике, у Float и Double одинаковы сами константы, но разные значения
* Методы класса Float:
* compare(float a1, float a2) - сравнивает 2 float и возвращает разницу, если а1 больше, то положительное возвращает.
* compareTo(Float f) то же самое, что compare, только в отношении объектов
* floatToIntBits(float a1) - возвращает IEEE-стандартизированную кобминацию двоичных разрядов одинарной точности, соответсвующей
* заданному числу
* static float intBitsToFloat(int число) - обратный предыдущему метод
* static int hashcode(float a1) - усовершенствованная версия метода hashcode() класса Object для Float
* isInfinite() - true, если число бесконечное
* is NaN - true, если объект NaN
* static float max(float a1, float a2) и static float min(float a1, float a2) - возвращают большее и меньшее значение соответственно
* static float parseFloat(String str) - парсит float из строки
* static String toHexString(float a1) - возвращает строку, содержащую это число в 16-м формате
* В классе Double - все методы те же.
* Заметка: NaN - это не "не число", это число, которое нельзя представить определенным значением. Т.е, ни строка, ни символ, например
* не являются NaN-ом. Это запомнить!
* Классы Byte, Short, Integer, Long:
* Константы в исходниках: основных 4
* Методы(перечислены те, которые не одинаковы с другими числовыми классами)
* Класс Byte:
* static Byte decode(String str) - возвращает объект Byte из строки
* static Byte parseByte(String str, int systemCount) throws NumberFormatException- особенность этого метода для Byte в том, что здесь в качестве параметра
* указывается система счисления, в которой будет выведено число.
* static Byte toUnsignedInt и static Byte toUnsignedLong - возвращает int и long соответственно без знака.
* Остальные такие же, как и во всех числовых классах
* Класс Integer:
* compareUnsigned(int i1, int i2) - сравнивает два числа без учета знака
* static int divideUnsigned(int i1, int i2) - результат i1/i2 без знака
* static Integer getInteger(String s, int base) - возвращает целое число из свойства, при неудачном исходе - базове значение. Если
* не указывать базовое значение, возвращает null.
* static int lowestOneBit(int i) - возвращает значение младшего бита, имеющего значение 1. Например, для 64 это 64, а для 65 уже 1.
* static int numberOfLeadingZeros(int i) - возвращает количество нулей слева. Если значение 0, возвращает 32
* static int numberOfTrailingZeros(int count) - если 0, возвращает 32. возвращает количество нулей справа
* static int reverse() - инвертирует биты числа.
* static String toBinaryString() toHexString() toOctalString() -- возвращает число в десятичной, шестнадцатеричной и восьмеричной формах соответственно
* Остальные более-менее схожи, подробнее можно посмотреть, если понадобится, позже
* Класс Character - класс-оболочка char.
* Константы в исходнике класса - их очень много! в районе 50-ти. Но основные вот:
* BYTES - лина в байтах, RADIX - основание системы счисления:
* Класс содержит большое число методов для определения характеристик объектов-символов, таких как, регистр букв, цифра или буква,
* какой-либо служебный символ, символ, имеющий зеркальную копию в Юникоде, например, и т.д.
* После Java 1.5, Character оддерживает 32-битный Юникод, в отличие от простого char, который поддерживает лишь 16-битный Юникод.
* В связи с этим появилось 3 термина: Кодовая точка - это символ в 32-битном Юникоде. Символы, выходящие за пределы 16-битного Юникода
* называются дополнительными. Основная многоязыковая плоскость - это символы 16-ти битного Юникода.
* Для работы с символами из 32-битного Юникода, используются методы класса Character, в которых в качестве параметра передается не
* char, а int. Тип int размером 32 бита, следовательно позволяет хранить любой символ кодировки Unicode-32.
* Еще, как вариант, можо использовать так называемую суррогатную пару символов char: первый символ - это старшая половина, второй символ -
* младшая половина. Метод int toCodePoint(char ch1, char ch2) преобразует суррогатную пару в одну кодовую точку Юникода-32.
* Класс Boolean: содержит две константы TRUE и FALSE. Является очень тонкой оболочкой, применяется очень редко, токо тогда, когда
* логические значения нужно передавать по ссылке. Содержит интересные методы, добавленные в JDK 8(содержит и все остальные методы,
* определенные в классе Object)
* static boolean logicalAnd(boolean op1, boolean op2) - выполняется операцию И над выражениями 1 и 2
* static boolean logicalOR и static boolean logicalXOR - аналогично для ИЛИ и исключающего ИЛИ
* Класс Void: содержит единтсвенное поле TYPE, в котором хранится ссылка на объект типа Class для типа void. Экземпляры этого класса
* не создаются. Не создаются, потому что у этого класса приватный конструктор, вот так то(Шилдт не гвоорит об этом).
* Класс Process: абстрактный класс, инкапсулирует процесс выполнения программы. Используется в качестве суперкласса для типа объектов,
* создаваемых методом exec() из класса Runtime или методом start() из класса ProcessBuilder.
* Абстрактные методы класса Process:
* void destroy() - прерывает процесс
* Process destroyForcibly() - принудительно завершает вызывающий процесс.
* int extValue() - Возвращает код завершения процесса.
* InputStream getErrorStream() - вызывает поток ввода из потока System.err
* InputStream getOutputStream() - вызывает поток ввода из потока System.out
* OutputStream getOutputStream() - вызывает поток вывода для записи данных в поток ввода System.in
* boolean isAlive() - возвращает true, если процесс работает
* int waitFor() - возвращает код завершения процесса(exit code)
* Класс Runtime - инкапсулирует исполняющую среду. Создать объект этого класса нельзя, но можно получить ссылку на текущий объект
* с помощью статического метода Runtime.getRuntime(). Создается один раз для процесса, при перезапуске процесса, объект остается тот
* же. По сути, с помощью класса управляется JVM.
* Методы этого класса:
* void addShutDownHook(Thread thread) - регистрирует поток, который должен быть запущен при остановке работы JVM.
* Process exec(String prog_name) throws IOException - выполняет программу, определнную в методе как отдельный процесс. Возвращает
* объект Process
* Process exec(String prog_name, String[] circle) throws IOException - ыполняет программу в заданном окружении.
* Process exec(String args[], String circle[]) - выполняет командную строку в окружении
* void exit(int code) - завершает процесс с кодом выхода. 0 - нормальное завершение, остальные - завершения с ошибками
* long freeMemory() - возвращает кол-во доступной JVM ОЗУ
* void gc() - инициатор сборки мусора
* static Runtime getRuntime() - возвращает текущий объект процесса.
* void halt(int code) - немедленно завершает работу JVM с заданным кодом
* Также методы подгрузки библиотек и финализаторы.
* Наиболее популярное применение класса: управление ОЗУ и выполнение доп.процессов:
* 1)Управление ОЗУ: Несмотря на то, что в Java работает очистка, иногда нужно узнать,
* насколько эффективна программа в плане расходования ресурса ОЗУ. В этом помогают методы freeMemory(), totalMemory() и gc().
* Методы вывода памяти позволяют оценить расход ОЗУ, а метод gc позволяет вызывать очистку тогда, когда нужно разработчику, например,
* для повышения места ОЗУ в конкретной части программы.
* Выполнение других программ: выполнение других процессов осуществляется с помощью метода exec(String prog_name). Данный метод
* возвращает ссылку на объект процесса. Вызов метода destroy() завершает процесс, а метод waitFor() заставляет прикладную программу
* ожидать завершения процесса.
* Класс ProcessBuilder:
* ProcessBuilder предоставляет более широкие средства для работы с процессами. В данном классе определены конструкторы:
* ProcessBuilder(List<String> аргументы)
* ProcessBuilder(String... аргументы) аргументы - это имя программы со всем аргументами командной строки
* ///Дописать позже
* Класс System: данный класс содержит коллекцию статических методов и переменных. Уже знает, что переменные in, out, err класса System-
* это переменные типов InputStream , PrintStream и также PrintStream соответсвенно.
* Методы класса System:
* static void arraycopy(Object источник, int begin, Object адресат, int adressorBegin, int size) - копирует массив. Копируемый
* массив передается в качестве источника, int begin - позиция, с которой начинается копирование. Массив-адресат - получатель копии,
* размер - количесвто передаваемых элементов.
* static String clearProperty(String str) - удаляет переменную окружения
* static Console console - возвращает консоль, связанную с JVM, в противном случае - null.
* static long currentTimeMillis() - возвращает кол-во миллисекунд , прошедших с полуночи 1 января 1970 г.
* static void exit(int code) - завершает программу и передает код родительскому процессу.
* static void gc() - сборка мусора
* static Map<String, String> getenv() - возвращает объект Map, содержащие текужие переменные окружения
* static Properties getProperties() - возвращает свойства, связанные с исполняющей системом в объекте типа Properties.
* static String getProperty(String str) - возвращает свойство по параметру str, если не найдено - null.
* static SecurityManager getSecurityManager() - вызывает текущий диспетчер защиты, или null.
* static Channel inheritedChannel - возвращает канал, наследуемый JVM или null
* static long nanoTime() - наиболее точный таймер системы, возвращает в наносекундах, точность таймера неизвестна
* У методов getSmth() также есть аналоги setSmth().
* У метода currentTimeMillis есть очень интересное применение: можно замерять время выполнения отдельных частей программы.
* Для этого монж заключить первый вызов метода в переменную один, второй вызов будет разницей между вторым вызовом и первым вызовом
* Переменных оркужения в Java много, пример приведен в программе ниже, где с помощью метода getProperty() вызывается свойство
* java.version, возвращающее текущее значение версии Java API, user.name - текущее имя пользователя и так далее. Эти свойства окружения
* можно подробнее изучить в нэте.
*
* Класс Object(святая-святых!!!) - Все методы, содержащиеся в этом классе, применимы для всех объетов в Java. Object является суперклассом
* для всех остальных классов. Методы, используемые в Object:
* ***********************************************************************************************************************************
* equals() - проверяет равенство объектов
* clone() - клонирует объект(Только те, которые реализуют Cloneable)
* toString() - возвращает строковое представление объектов
* hashcode() - возвращает хеш-код объекта
* notify() - прерывает исполнение потока, вызывающего объект
* notifyAll() - прерывает исполнение всех потоков, ожидающих вызывающий объект.
* finalize() - зло!!! Финализаторы лучше не использовать
* final Class<?> getClass() - вызывает объект типа Class, описывающий объект
* final void wait() throws InterruptedException - ожидает завершения другого потока исполнения. Есть версии метода с указанием точного времени
* ***********************************************************************************************************************************
* Это методы, которые может использовать любой Java-объект. Пример приведен в программе ниже.
* Подробнее про хеши в Java - хеш-код в Java - это целочисленный результат типа int работы метода hashcode(Object obj), который
* генерирует хеш-коды для объектов. Важно понимать, что для разных объектов всегда будут разные хеш-коды!. Но, если хеш-коды,
* то объекты не всегда одинаковы! Так как, число хеш-кодов ограниченно типом int, а число объектов - неограниченно. Ситуация, когда
* для разных объектов генеирруется один и тот же хеш-код называется коллизией. Вероятность коллизии зависит от используемого при
* хешировании алгоритма.
* Применение метода clone() и интерфейса Clonable() - Clonable говорит о том, что объект дпускает собственное поразрядное копирование
* При попытке вызвать clone() для объекта, не поддерживающего Cloneable бросается исключение CloneNotSupportedException. Клонирование -
* потенциально опасное действие. Если изменить клон - изменится и оригинал. Если объект открывает поток i/o и вызывается клон, то
* оба объекта будут оперировать одним и тем же i/o потоком. Но такое положение дел обеспечивается при реализации clone(), определенной
* в Object, поэтому, если и нужно клонировать объект, метод нужно переопределить. Реализовывать клонирование в программе, без серьезной
* на то причины, не стоит, так как это может серъезно нарушить логику программы.
* Класс Class(класс класс, забавно)
* Этот класс инкапсулирует состояние времени выполнения класса или интерфейса. Во-первых, у этого класса приватный конструктор.
* При объявлении любого класса, объекты этого класса неявно создаются. Для получения объекта типа Class используется метод getClass()
* из класса Object. Class - обобщенный финальный класс, обозначен как public final class Class<T>. Класс ClassLoader - абстрактный
* класс, определяющий порядок загрузки классов. Его можно расширять, устанавливая свой порядок загрузки, но делать этого обычно не нужно
* Пример метода из класса Class в программе, подробнее можно узнать позже
* Класс Math: этот класс инкапсулируем методы , применяемые в тригонометрии и геометрии. В классе Math определено 2 константы:
* E = 2.718281828459045D, PI = 3.141592653589793D типа double. Класс предоставляет набор методов для вычисления тригонометрических,
* обратных тригонометрических, экспонециальных, функций окргуления и различные прочие математические операции.
* Все методы Math - статические. Основные: exp(x) - возвращает E^x, log(x) - возвращает ln(x) , log10(x) - возвращает lg(x)
* pow(x,y) - возвращает x в степени у, cbrt(x) - возвращает кубический корень х, sqrt(x) - квадратный корень х.
* ceil(x) - округляет х в большую сторону, floor(x) - округляет х в меньшую сторону, max(x,y) - возвращает большее из х и у
* min(x,y) - возвращает меньшее из x и y, rint(x) - возвращает ближайшее целое значение, round(x) - возвращает ближайшее целое значение
* signum(x) - возвраащет 1, если число положительное, возвращает -1 если отрицательное, 0 если 0, toRadians(x) переводит градусы в
* радианы. toDegrees(x) - переводит радианы в градусы.
* Класс StrictMath - более точные методы из класса Math, но более ресурсозатратные.
* Класс Compiler - инкапсулирует средства перевода байт-кода в исполняемый, в программировании не используется
* Классы Thread, ThreadGroup и интерфейс Runnable - поддержка многопоточного Java-программирования.
* Runnable - интерфейс нового потока, который содержит в себе один метод run()(по сути, функциональный интерфейс).
* Метод run() - это точка входа в поток исполнения. Этот метод обязательно д/б реализован
* Класс Thread - новый поток исполнения, реализующий Runnable
* Конструкторы:
* Thread()
* Thread(Runnable поток, String имя_потока)
* Thread(Runnable поток)
* Thread(ThreadGroup группа, Runnable runnable)
* Thread(ThreadGroup tgroup, String threadName)
* Thread(ThreadGroup tgroup, Runnable runnable, String threadName)
* runnable - экземпляр класса, реализующего Runnable
* threadName - имя потока, если не указано, генерируется JVM
* tgroup - группа потоков, если не указана, будет отнесен к группе родительского потока
* В классе Thread определены константы приоритетов потоков. Приоритеты определены от 1 до 10. Нормальный приоритет = 5.
* Информация о работе с Thread и Runnable описаны в классе JavaMultiThreading. Здесь описан класс ThreadGroup
* ThreadGroup - группа потоков исполнения. Позволяет управлять потоками как одним целым. Это требуется, когда нужно приостановить
* или продолжить выполнение нескольких взаимосвязанных потоков исполнения.
* Позже, заполнить методы этих классов:...
* Классы ThreadLocal и InheritedThreadLocal - локальные потоки, которым присваивается своя локальная переменная. Отличие второго в том,
* что он может наследоваться.
* Класс Package - инкапсулирует данные о версии пакета. Пример в программе: Методы также позже:
* Класс RuntimePermission - класс механизма защиты Java
* Класс Throwable - суперкласс всех исключений, все уже о нем знаем
* Класс SecurityManager - суперкласс диспетчеров защиты для создания собственных диспетчеров защиты
* Класс StackTraceElement - содержит стековый фрейм - строка, выпадающая при возникновении исключения в конкретной точке выполнения.
* Стековый фрейм включает в себя имя класса, метода, файла и строки исходного кода
* Класс Enum - от него наследуются все перечисления. Имеет вид: class Enum<E extends Enum<E>>. E - перечислимый тип
* Методы класса Enum применимы ко всем перечислениям.
* Класс ClassValue - нужен для связи значения с типом. Вид: class ClassValue<E> - E - тип данных
* Интерфейсы пакета java.lang
* CharSequence - интерфейс реализации последовательности символов. Реализуется в String, StringBuilder, StringBuffer и др.
* Comparable<T> - объекты, реализующие этот интерфейс могут быть упорядочены. Например, те же строки или оболочки типов.
* Имеет единственный метод compareTo().
* Appendable - интерфейс реализует функцию добавления символов к объекту. Единственный метод append. Может добавлять как char,
* так и CharSequence.
* Iterable - объект, класс которого релизует этот интерфейс может быть перебран с помощью for-each. Имеет 3 метода -
* iterator()  spliterator() и forEach(). Метод forEach использует функциональный интерфейс Consumer<T> из пакета java.util.function
* Readable - интерфейс определяет возможность объекту быть использованым как источник для чтения символов. Содержит
* единственный метод read()
* AutoCloseable - нужен для реализации оператора try с ресурсами(для того, чтобы не прописывать закрытие файла, потока и т.д)
* Подпакеты java.lang()
* java.lang.annotation - средства аннотирования
* java.lang.instrument - доп.инструменты для всех аспектов программ
* java.lang.invoke - поддержка динамических языков
* java.lang.management - средства управления JVM
* java.lang.ref - гибкое управление сборкой мусора
* java.lang.reflect - рефлексия - способность программанализировать код во время выполнения. Динамическое определение
* характеристик компонентов. Содержит классы, которые отвечают за анализ компонентов программ: Field, Method, Constructor, а также
* интерфейсы Member и Type. Также, в этот подпакет входит класс Array, позволяющий динамически работать с массивами.
*
*
*
*
*
*
* */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.util.Map;

import static java.lang.Float.toHexString;
public class JavaLang{
    public static void main(String[] args) {
        System.out.println(Runtime.getRuntime().freeMemory());
        long r2 = System.currentTimeMillis();
        System.out.println(r2);
        Float v = 12323F;
        Process pr;
        Double y = 135.3;
        Integer i = 65;
        System.out.println(Integer.lowestOneBit(i));
        Byte b = 127;
        Character c = 'c';
        String s = "123";
        System.out.println(Runtime.getRuntime().freeMemory());
        char c16 = (char) 0x11FFFF; //и для обычного char работает
        Character c32 = (char) 115; // В общем, работает 32-битный Юникод
        String e = toHexString(v);
        System.out.println(); //вывел ссылку на текущий объект Runtime.
        System.out.println(e);
        double g = Math.PI * 3;
        try {
            System.out.println("Notepad opened");
            pr = Runtime.getRuntime().exec("notepad"); //ОН ЗАПУСТИЛ БЛОКНОТ!!! АХЕРЕТЬ!!!!))))))))
            pr.waitFor(); // метод ждет закрытия блокнота
        }
            catch (Exception ioEx) {
            System.out.println("Error");
        }
        Runnable run = () -> {
            int count = 10;
            try {
                do {
                    Thread.sleep(1000);
                    count--;
                    System.out.println(count);
                }
                while (count != 0); System.out.println("РАКЕТЫ НА США ЗАПУЩЕНЫ");
            } catch (Exception exce) {
                System.out.println("fsf");
            }
        };
        run.run();

       /* System.out.println("Notepad closed");
        System.out.println(System.currentTimeMillis() - r2); //риколньо
        Map<String, String> mapE = System.getenv(); //содержит 41 переменную среды
        System.out.println(mapE.size());
        System.out.println(System.getProperty("java.version")); //на момент запуска программы 1.8.0_152-release)
        System.out.println(System.getProperty("user.name")); //выдает имя пользователя и т.д.
        System.out.println(y.getClass()); //Класс java.lang.Double
        System.out.println(s.hashCode()); //значение хеш-кода для символов равно их 10-му значению в Юникоде))
        s.equals(c32);
        System.out.println(y.getClass().getClassLoader()); //ClassLoader - null для базового класслоадера
        System.out.println(Math.exp(1));
        System.out.println(Package.getPackage("com.maxonchik.OOP").getImplementationVersion());*/
        }

    }

/*a>=b && c<b return b*/
