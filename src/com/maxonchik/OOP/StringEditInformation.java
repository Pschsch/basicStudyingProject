package com.maxonchik.OOP;

/*Начинаю рассматривать Java из полного руководства Шилдта. Рассмотрение всей стандартной библиотеки Java 8
* Для каждой библиотеки отдельный класс.*/
/*******************************************Обработка символьных строк*****************************************************************
* Как известно, строки - это последовательность символов, которая в Java является объектом класса String.
 * Строки - это неизменяемые объекты. Всякий раз, когда в строку вносятся изменения, создается новый объект строки, содержащий все
 * внесенные изменения. Реализация строк в виде объектов позволяет проводить более удобную их обработку: в частности, сравнивать,
 * конкатенировать, искать подстроки и так далее. Если эе нам необходимы изменяемые версии строк, в Java предусмотрено 2 класса:
 * StringBuilder и StringBuffer. бъекты обоих классов содержат строки, которые могут быть изменены после их создания. Но, эти строки
 * являются типами StringBuilder и StringBuffer, а не String, поэтому не могут быть использованы как String.
 * Классы String, StringBuilder и StringBuffer определны в пакете java.lang поэтому, импортировать эти классы не нужно.
 * Все эти классы - final, следовательно от них нельзя наследоваться. Все три класса реализуют интерфейс CharSequence.
 * Примечание: сами строковые объекты неизменяемы, но переменная, ссылающаяся на один строковый объект может быть в любой момент
 * изменена на ссылку на другой строковый объект.
 * Конструкторы символьных строк:
 * Можно инициализировать массивом символов, начальными и длиной строки части этого массива символов.
 * char[] charArray = {'a','b','c'};
 * String s = new String(charArray)
 * String s2 = new String(charArray, 1, 2);
 * Можно создать новый строковый объект на основе существующего:
 * String s = new String("String");
 * String s2 = new String(s);
 * Строки также можно инициализировать массивов байтов:
 * String s = new String(byte символы[]); - такая инициализация позволяет оптимизировать вывод символов в строках к разным
 * кодировкам.
 * Строки можно создать из объектов буфера строк и строителя строк:
 * String(StringBuffer sbfObj);
 * String(StringBuilder sblObj);
 * Длина символьной строки - количество символов в ней. Узнается с помощью метода length()
 * String s = "String" //Создание объекта String из строкового литерала
 * s.length(); // Равна 6
 * Для строкового литерала, автоматически создается объект String.
 * Например: System.out.println("abc123") //Здесь неявно был создан объект String для этого строкового литерала
 * Строки можно конкатенировать с помощью +:
 * "one" + "two";
 * Конкатениация с другими типами данных:
 * int i=2;
 * "string"+i+i; - другие типы данных преобразуются в строковые эквиваленты и конкатенируются обычным образом
 * Результат этой операции будет "string22"
 * Чтобы получить "string4", нужно заключить i+i в скобки:
 *"string"+(i+i);
 * Преобразование символьных строк:
 * Метод toString(): определен в классе Object, возвращает строковое представление объектов. Шилдт рекомендует переопределять
 * метод toString() (чет как-то сомнительно, но может где-то и оказывается нужно)
 * Извлечение символов:
 * 1)Метод charAt(int index) - извлекает символ из строки по индексу: Пример:
 * String s = "abc";
 * char mC = s.charAt(int 2);
 * 2)getChars(int i, int i1, char[] chars, int i2)
 * i - начальный индекс, i1 - конечный, chars - буфер выводимых символов,i2 - начальный индекс буфера символов
 * 3)toCharArray() - преобразует String в char[].
 * Сравнение: методы:
 * 1)equals() - с ним все ясно, просто сравнивает, если равны, то возвращает true
 * 2)equalsIgnoreCase() - equals(), который игнорирует регистр символов, наборы A-Z и a-z для него одинаковы.
 * 3)regionMatches(int начальный_индекс, String строка_2, int индекс_начала_строки2, int количество_символов)
 * Сравнивает сабстринг вызывающей строки с сабстрингом строки, переданной в качестве параметра String этому методу.
 * 4)startsWith() и endsWith() - определяют, начинается ли строка или заканчивается на заданную подстроку в этих методах.
 * По сути, специализированный аналог regionMatches().
 * String s = "Foobar"
 * s.startWith("Foo"); // Даст true
 * s.endsWith ("bar"); // Даст true
 * 5)compareTo() - сравнивает строки и выдает разницу между ними в лексикографическом порядке(т.е по алфавиту).
 * Метод переводит символы в их целочисленные значения и сравниваем уже целочисленные значения.
 * compareToIgnoreCase() - сравнение без учета регистра. Заглавные буквы приравниваются к строчным.
 * 6)indexOf() и lastIndexOf() - поиск первого и последнего вхождения символа в строку, возвращает индекс
 * Видоизменение строк:
 * Видоизменения происходят с помощью копирования объекта строки в строитель или буфер строк, или методами класса String:
 * 1)substring(int begin, int end) - извлекает из строки подстроку в новый объект String. В качестве параметров передаются
 * индексы начала и конца подстроки.
 * 2)concat(String s) - метод конкатенации строк, аналогичен оператору +.
 * 3)replace(char begin, char end) - заменяет один вид символов в строке другим
 * Вторая версия метода:
 * replace(CharSequence begin, CharSequence end) - заменяет последовательность символов другой последовательностью.
 * 4)trim() - из вызывающей строки удаляются все начальные и конечные пробелы
 * 5)valueOf()-етод преобразует числовые типы в строковые представления
 * 6)toLowerCase() и toUpperCase() - овышение либо понижение регистра символов
 * 7)join(CharSequence разделитель, CharSequence строки...); - соединяет строки через разделитель
 * 8)codePointAt(int i) - озвращает кодовую точку в Юникоде на позиции i(десятичный индекс Юникода)
 * 9)codePointBefore(int i) - возвращает кодовую точку на позиции i-1.
 * 10)static String format(String form_string, Object аргументы...) - возвращает отформатированную строку
 * о форматировании далее...
 * Дргуой вариант включает Locale регион(он использован в нашем приложении)
 * 11)boolean matches(String регулярное_выражение) - true, если совпадает с регулярным выражением(в пакете java.util)
 * 12)String replaceFirst(String регулярное_выражение, String новая_строка)
 * 13)String replaceAll(String регулярка, String новая_строка) - все подстроки, совпадающие с регуляркой, заменяются на новые
 * 14)String[] split(String регулярка) - возвращает массив строк, которые являются частями вызывающей строки, разбитые регулярными
 * выражениями.
 * Есть еще вариант с заданным максимумом частей.
 * 15)CharSequence subSequence(int begin_index, int end_index) - типо сабстринга для чарсиквэнс.
 * Классы для видоизменения строк:
 * StringBuffer: этот класс подобен классу String. Этот класс предоставляет расширенный функкционал для работы со строками.
 * Он позволяет вставлять подстроки и символы в середину строк, экземляры этого класса автоматически наращиваются.
 * StringBuffer содержит 4 конструктора:
 * 1)StringBuffer()
 * 2)StringBuffer(int size)
 * 3)StringBuffer(String str)
 * 4)StringBuffer(CharSequence text)
 * 1-й конструктор, по умолчанию, предоставляет место для 16 символов. 2-й явно задает место для определенного кол-ва символов.
 * 3-й задает начальное содержимое буфера строк + 16 символов
 * 4-й тоже самое, что и 3-й, только принимает интерфейс CharSequence
 * Такой подход к выделения памяти позволяет избежать частого перераспределния памяти и фрагментации памяти
 * Методы класса StringBuffer:
 * length() - длина буфера строк, capacity() - кол-во выделенной памяти. Протестируем:
 * метод capacity для пустого буфера строк выводит значение 16, все правильно.
 * ensureCapacity(int capacity) - метод установления емкости буфера.
 * setLength(int length) - адает максимальную длину строки в объекте StringBuffer, если выходит за диапазон, после него символы удаляются
 * chatAt(int index) и setCharAt(int index, char ch) - значение символа в объекте StringBuffer в определенном индексе, и
 * засеттить символ в определнном индексе в StringBuffer
 * getChars выполняет ту же функцию, что и для объектов String
 * append() - имеет 3 варианта:
 * 1)append(String str) - просто присоедтняет строку
 * 2)append(int num) - конкатенирует числовое значение
 * 3)append(Object obj) - конкатенирует строковое представление объекта
 * insert() - метод вставляет одну строку в другую. То же что и append, только может вставлять строку в заданный индекс.
 * Все коснтрукторы те же, только в каждом добавляется параметр int index - начало вставки строки в другую строку.
 * reverse() - инвертирует порядок символов.
 * delete(int begin, int end) deleteCharAt(int index) - удаление последовательности символов из строки в заданном пределе
 * и удаление символа в конкретном индексе соответственно
 * replace(int begin, int end, String str) - заменяет на переданную строку в заданном диапазоне
 * substring(int begin, int end) - одстрока из буфера строк с начальным и конечным индексами
 * trimToSize() - уменьшает размер буфера до длины буфера строк
 * Класс StringBuilder
 * Появился в JDK 5. Полный аналог StringBuffer за исключением того, что StringBuilder не синхронизирован, следовательно его
 * можно применять только в том случае, если объект StringBuilder обрабатывается в одном потоке. В случае нескольких потоков,
 * надо использовать StringBuffer
 *
 *
 *
 *
 *
 *
 *
 * */
public class StringEditInformation {
    public static final String S = "s123456789";
    public static void main (String args[]){
        CharSequence begin = "abc";
        StringBuilder mBuf = new StringBuilder();
        mBuf.ensureCapacity(16);
        String[] sArr = {"123","faskhfkajsfh","saufhiuashfgv","dfsahfajs"};
        String s =("П**да");
        StringBuilder sbuf = new StringBuilder(s);
        sbuf.reverse();
        for (String e:sArr) {
            mBuf.append(e);
        }
        System.out.println(s.codePointAt(4));
        System.out.println(begin);
        System.out.println(mBuf.capacity());
        System.out.println(mBuf.toString());
        System.out.println(sbuf);
        System.out.println(mBuf.length());//но выбило 34, Java сама выделяет нужный буфер, 17 и выше до 34 выбивает 34
        //ниже 16 не может быть
    }

}
