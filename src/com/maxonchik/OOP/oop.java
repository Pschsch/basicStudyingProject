package com.maxonchik.OOP;
/*3 основных парадигмы Объектно-ориентированного программирования:
1)Инкапсуляция
2)Наследование
3)Полиморифзм
Итак, начнем
1]Первый принцип ООП, который мы рассмотрим - это наследование. Очень удобная вещь, позволяющая
сэкономить кучу времени и сократить большое количество ненужного кода.
Допустим, наш класс оор содержит какие-то общие свойства
Теперь, нам надо создать класс, который обладает этими свойсвтами, но вдобавок имеет
какие-то свои собственные. Чтобы не приписывать общие свойства этому классу второй раз
и сущетсвует наследование. Все одинаковый свойства классов выделяются в отдельный класс,
который называют родительским, а классы, которые наследуются от него - дочерними.
Наследование применяет с помощью специального оператора extends. В нашем случае oopsecond
наследует от оор.
В Java может быть только один родительский класс. Потому что возникает проблема ромбовидного наследования.
Дерево наследований нельзя делать ниже 4-5 уровней.
Ключевое слово super - применение- вызов параметров суперклассов в подклассах. Общий синтаксис:
super (список_параметров);
1)Конструкторы: при использовании в конструкторах, необходим для вызова элементов родительского конструктора в конструктор подкласса.
Пример приведен в oop(родиетль) и oopsecond(подкласс) . Конструктор класса oopsecond наследуется от oop и содержит все параметры
суперкласса. Чтобы не прописывать в конструктор подкласса еще раз эти значения, просто сошлемся на них с помощью слова super.
вызов слова super всегда должен идти первым в теле конструктора. 2)Ключевое слово super может играть роль ключевого слова this
для классов-родственников. Эта роль заключается в предотвращении сокрытия имен переменных. Конечно, лучше, если общие
переменные родительских классов все будут прописаны в суперклассе(!!!), но если так получилось, что переменная нужна в подклассе с
этим же названием, то для доступа в подклассе к переменной или методу суперкласса можно использовать super.
3) Использование в многоуровневой иерархии классов. Допустим у нас есть иерархия из классов А Б В. В от Б, Б от А.
При использовании super  классе В, будут вызываться параметры класса Б, в классе Б - параметры класса А. Таким образом,
если нам необходимо доставить параметры класса А в класс В, их нужно передать "по эстафете" через класс Б с помощью слова super.
2] Полиморфизм - очень мощное средство, достижение объектно-ориентированного программирования
1)Переопределение
Если коротко, то в Java - это использование методов родительских классов объектами дочерних классов.
Примеры представлены с помощью классов оор и oopsecond в классе main.)
у нас есть метод getUran, который возвращает значение параметра uran для класса оор.
Но нам необходимо использовать этот метод в другом классе oopsecond, чтобы он выполнил ту же ф-b.
но выдал нужное нам значение для этого класса. Для этого мы ПЕРЕОПРЕДЕЛЯЕМ ЭТОМ МЕТОД В КЛАССЕ
oopsecond!!!! При переопределнии метода в другом классе лучше использовать аннотацию @Override
Аннотация нам сообщит, если вдруг у нас возникнет какая-нибудь ошибка при переопределнии
Далее, чтобы мы могли использовать переопределенный метод, объект создается в таком формате:
"класс с методом" "объект" = "new" "класс с переопределенным методом"*/
/*Важно, чтобы классы были родственниками*/
/*Например: представим, что  у нас есть какая-то формула расчета, например, зарплаты для
 всех классов сотрудников. Но, какой-то из классов сотрудников должен получать зарплату по
 другой формуле расчета. В таком случае, применяя метод расчета зарплаты для этого особенного класса
 сотрудников, мы "перегружаем" метод расчета зарплаты , вводя в него ту формулу расчета,
 которая нам необходима для данного класса. В Java возможно переопределять все методы!!(кроме
 final) Если метод не был переопределен, то исполнится метод из родительского класса*
 Такая форма переопределнных методов с использвоанием родственных классом называется Overriding.
 Собственно, отсюда, аннотация @Override
 Этот способ особенно удобен, когда происходит работа с целыми массивами объектов(массив-это тоже объект в java)))
 когда, из 100 объектов, к 99 применяется метод по одной формуле, а к 100 нужна другая формула
 Переопредление методов - это не просто возможность использовать метод с одним названием для разных объектов с разными
 параметрами. Основная функция, которую выпоняет этот способ - динамическая диспетчеризация методов. Она обеспечивает возможность
 поиска подходящего метода во время выполнения программы. Ссылочная переменная суперкласса может ссылаться на объект подкласса.
 Если вызов переопределнного метода осуществляется с помощью ссылки на суперкласс, то исполняющая система Java ыбирает
 нужную версию метода на основании типа на который эта ссылка указывает в момент вызова. То есть, в момент выполнения программы,
  если у нас есть метод суперкласса, переопределенный в подклассе, то исполнится тот метод, в зависимости от типа объекта ссылки, а
  не типа ссылочной переменной. Т.е вызовется метод, соответсвующий объекту, на который ссылается переменная суперкласса.
  пример в oop:
 2) Перегрузка: Несколько методов одного и того же класса могут иметь разные имена, но выполнять схожий функционал и
 отличаясь лишь набором праметров. Для того, чтобы перегрузить метод, необходимо просто объявить его новый вариант, а остальное
 сделает компилятор. нужно соблюсти обязательное условие: тип и/или число параметров в перегружаемых методах должно быть разным.
 Одной лишь разницы в типах возвращаемых значений недостаточно, так как не будет хватать информации о том, какой метод
 использовать. Пример:
 public void myMeth1(){System.out.println("The basic variant of the method")};
 public void myMeth1(int a){{System.out.println("Overload number 1")};
 public int myMeth1(int a,b){{System.out.println("Overload number 2");return a+b;};
 public double myMeth1(double a,b)(System.out.println("Overload number 3");return a+b;);
 Соответственно, будет вызыватся тот метод, в зависимости от того, что мы ему передадим в качестве аргументов, например:
 someClass someobj = new someClass();
 someobj.myMeth1();  //Здесь вызовется первоначальнач версия метода myMeth1, так как нет никаких параемтров
 someobj.myMeth1(2.3,5.3);//Здесь вызвется четвертая версия метода, так как аргументы, переданные методу типа double
 Важно знать, что в перегружаемых методах, переменные типа byte short автоматически преобразуются в int, float в double.
 в том случае, если нет прямого сходства. Например, метод abs() из класса Math автоматом перегружается, исходя из типа
 переданных аргументов. Перегружать можно только сильно взаимосвязанные между собой методы, выполняющие одну и ту же ф-ию
 с разными типами данных!!!
 3) Инкапсуляция - это представление класса в виде "черного ящика". Т.е мы "не знаем", как устрен класс.
 Суть инкапсуляции заключается в том, что все поля данных класса должны быть закрыты, чтобы, если
 необходимо поля редактировать, и если на эти поля происходят ссылки в других местах программы,
 не переписывать код в других местах программы.
 Коротко: Инкапсуляция - это работа с приватными полями данных объекта через публичные методы.
 Она позволяет более гибко редактировать проект программы с меньшими трудозатратами.
 SOLID - 5 принципов проектирования ООП программ
 1) Принцип разделения ответвенности - каждый класс отвечает за единственную функцию
 2)Принцип доступности
 3) принцип подстановки Лисков
 4)принцип изоляции интерфейсов
 5)принцип инверсии зависимостей
 */



public class oop {

    public double GlobalVal=30; // переменная суперкласса
    public int uran;
    public int neptun;

    public oop(int Uran, int Neptun) {
        uran = Uran;
        neptun = Neptun;
    }
    public void getUran(){
        System.out.println("Basic method ");
    }
}




