package com.maxonchik.OOP;
/*Информация о многопоточной обработке*/
/*Различают 2 разновидности многопоточной обработки: на основе процессов и на основе потоков. Процесс - это, по сути, исполняемая
* программа. Поэтмоу многозадачность на основе процессов - это возможность исполнения нескольких программ одновременно. Например,
* эта форма многозадачности позволяет одновременно запускать компилятор, работать с текстом и просматривать информацию в Интернете
* параллельно. При организации такой многозадачности, программа является наименьшей единицей кода, выполнение которой координирует
* планировщик задач. При организации многозадачности на основе потоков, наименьшей единицей кода является поток. Это означает,
* что в рамках выполнения программы, одновременно выполняется несколько задач. Например, программа может форматировать текст
* одновременно с его выводом на печать, при условии, что эти действия выполняются одновременно в двух потоках. В самих программах
* доступна многозадачность только на основе потоков. Главное преимущество такой обработки - использование периодов простоя ЦП.
* Соответсвенно, эффективность использования ресурсов ЦП такими программами возрастает в разы. Например, устройства ввода-вывода,
* дисковые накопители работают гораздо медленнее, чем ЦП, а значит при работе с данными устройствами будет неизбежно возникать
* период простоя, когда необходимо записать или считать информацию с внешних устройств. Соответственно, в такие моменты, если
* программа реализует многопоточность, могут выполняться какие-то другие операции. В многоядерных системах, потоки выполняются
* одновременно, в одноядерных - используют периоды простоя ЦП. Потоки могут находиться в нескольких состояниях: выполняющиеся -
* готовые к выполнению, как только они получат время и ресурсы ЦП для своей работы, приостановленный, т.е временно не
* выполняющийся, возобновленный - в дальнейшем, заблокированный - в ожидании ресурсов для своего выполнения, завершенный -
* выполнение завершено и не может быть возобновлено.
* При работе с многопоточностью используется режим - синхронизация. Данный режим позволяет координировать выполнение потоков
* строго определенным образом. Для такой синхронизации в Java используется отдельная подсистема.
*
* Класс Thread и интерфейс Runnable
* В основу системы многопоточной обработки положены класс Thread и интерфейс Runnable. Данные класс и интерфейс определены в
 * пакете java.lang. Thread инкапсулирует поток исполнения. Для того, чтобы образовать поток, нужно создать подкласс класс Thread
 * или класс, имплементирующий интерфейс Runnable.
 *
* Методы класса Thread:
* final String getName() - Получает имя потока
* final int getPriority() - получает приоритет потока
* final boolean isAlive() - определяет, выполняется ли поток
* final void join() - ожидает завершения потока
* void run() - определяет точку входа в поток
* static void sleep(long миллисекунд) - Приостанавливает выполнение потока на указанное число миллисекунд
* void start() - запускает поток, вызывая его метод run()
*
* В каждом процессе имеется ,как минимум ,один основной поток. От него уже порождаются другие, подчиненные потоки. Ранее, во всех
* моих программах использовался основной поток.
*
* Создание потока:
* Для того, чтобы образовать поток, нужно создать подкласс класс Thread или класс, имплементирующий интерфейс Runnable, как уже
* было написано ранее. Оба способа, с точки зрения работы класса-потока одинаковы, отличаются лишь способом создания класса-потока
* Интерфейс Runnable дает абстрактное описание единицы исполняемого кода. Для формирования потока, подходит любой класс, реализующий
* этот интерфейс. В интерфейсе Runnable объявлен только один метод - public void run().
* В теле метода run() определяется код, соответствующий новому потоку. Из этого метода можно вызывать другие методы, использовать
* в нем различные классы и объявлять переменные также, как и в основном потоке. Единственное отличие состоит в том, что метод
* run() создает точку входа в поток параллельно с основным, и выполняется до тех пор, пока не произрйдет возврат из метода.
* После создания класс, реализующего интерфейс Runnable, нужно создать экземпляр класса Thread на основе объекта данного класса.
* Конструкторы класса Thread:
* Основной конструктор для создания объекта, реализующего интерфейс Runnable:
* Thread (Runnable threadOb) - где threadOb - объект класса, реализующего Runnable. Это позволяет определить начало потока.
* Thread (Runnable threadOb, String name) - в этом конструкторе потоку еще задается конкретное имя потока.
* Созданный поток не будет запущен, пока не будет вызван метод start() из класса Thread. По сути, вызов start() нужен для вызова
* run().
* Алгоритм вызова работы потока: 1) Для начала создает объект класс, имплементирующего интерфейс Runnable в основном потоке.
* 2)Далее, на основе этого объекта, воспользуемся конструктором объектов класса Thread для создания объекта потока
* 3)Запускаем поток с помощью метода start(), который вызывает сразу же метод run();
* 4)Метод run() в нашем случае выполняется параллельно с кодом, введеным в теле потока
* Поток можно запустить, путем простого объявления объекта потока. Делается это с помощью конструктора имплементирующего класса
* или класса-наследника Thread: создается ссылка на поток, этой ссылке присваивается новый объект Thread:
* myThread(String name){
* thrd = new Thread(this, name) // name ,если есть
* thrd.start();} В таком случае, при объявлении метода start через конструктор, поток вызовется сразу.
* Главная рекомендация: основной поток ВСЕГДА должен завершаться последним. Это рекомендкется, так как в основном потоке
* выполняются действия по подготовке к завершению программы, например, закрытие файла. Если порожденные потоки не завершены
* до завершения основого потока, то нужно организовать ожидание завершения порожденных потоков.
* Зачем существуют 2 способа объявления потока: у каждого своя особенность
* 1) Порождать класс от класс Thread нужно в том случае, когда нужно дополнить класс новыми функциями, помимо метода run().
* 2) Реализация интерфейса Runnable позволяет наследоваться от класса, отличающегося от Thread.
* Определение момента завершения потока:
* Ранее, просто поддерживалось выполнение основого потока, пока не завершится порожденный поток. Для этого, основной поток удерживался
* с помощью метода sleep(). Но это не является удовлетворительным решением в большинстве случаев. Для этого есть более совершенные
* приемы. 1) метод final boolean isAlive(); - этот метод выдает true, если поток еще выполняется. С помощью данного метода, можно
* ожидать конца завершения порожденных потоков с использвоанием цикла do-while.
* 2) метод final void join() throws InterruptedException; - этот метод ожидает завершения потока, к которому был вызван.
* Это метод и исползуется для управления ожиданием основого потока. Переделаем do-while цикл с использвоанием метода isAlive()
* на join():
*
* Приоритеты потоков: с каждым потоком ассоциируется определенный приоритет. Чем приоритетней поток, тем больше доля выделяемого
* процессорного времени на исполнение потока в определенном промежутке времени. Отсюда следует: время ЦП на поток напрямую
* влияет на совместную работу потоков, может получаться разный результат. Помимо приоритета, на частоту доступа потока к ЦП
* влияют и другие факторы: если высокоприоритетный поток ожидает ресурсы, то он блокируется и исполняется другой поток, который
* более низкоприоритетный. Но, когда высокоприоритетный поток возобновится, он прервет низкоприоритетный и продолжит работу.
* В общем, если поток выше приоритетом, чем другой поток, это не означает, что высокоприоритетный исполнится быстрее,
* это говорит лишь о том, что потенциально, он может получить больше времени ЦП. При запуске порожденного потока, его приоритет
* устанавливается равным родительскому потоку. Изменить приоритет можно, вызвав метод setPriority() класса Thread:
* final void setPriority(int уровень) Уровень может быть только от 1 до 10!!! Значение 5 - это NORM_PRIORITY! стандартное
* значение. Константы приоритетов потоков определены как static final в классе Thread.
* 2-я программа: проверка зависимости приоритета от времени доступа к ЦП с помощью счетчика и цикла do-while:
* Синхронизация - При использовании нескольких потоков, возникает необъодимость в координации между ними. Процесс, который
* реализует этот механизм называется синхронизацией. Наиболее частое использование синхронизации - когда нескольким потокам,
* использующим один ресурс он доступен, и потоки должны его разделять. Например, когда в потоке идет запись в файл, второму
* потоку должно быть запрещено это делать, так как это пустая трата ресурсов. Синхронизация требуется тогда, когда один
* поток ожидает событие, которое произойдет в результате работы другого потока. Т.е требуется средство, которое переведет в
* статус ожидания первый поток, пока это событие не произойдет. После этого, ожидающий поток может возобновить свое выполнение.
* Главное понятие в синхронизации - монитор. Монитор реализует принцип блокировки. Если объект заблокирован одним потоком,
* то он оказывается недоступным для других. В какой-то заданный момент, объект разблокируется и будет доступен другим потокам.
* У каждого Java-объекта есть свой монитор. Этот механизм встроен на уровне языка. Следовательно, синхронизировать можно
* любой объект. Для поддержки синхронизации, в Java предусмотрено ключевое слово synchronized и ряд методов.
* Использование синхронизированных методов:
* Для объявления синхронизированного метода нужно прописать перед методом ключевое слово synchronized. Когда такой метод получает
* управление, производится активация монитора объекта и объект блокируется для других потоков. Когда выполнение метода завершится
* объект разблокируется для работы с другими потоками. Т.е не нужно прилагать осбых усилий для достижения синхронизации.
* Если метод не синхронизировать, и при этом он может быть доступен нескольким объектам, то, тогда при использовании метода
* с разными потоками будет происходить одновременная работа потоков с методом. Если же метод будет синхронизирован, то
* метод сначала отработает с одним потоком, а затем с другим. В случае одновременного вызова, будет происходить искажение результатов
* что очеыидно.
* ИТОГ:
* Синхронизированные методы создается с помощью слова synchronized в объявлении метода
* Как только сихнронизированный метод любого объекта получает управление, объект блокируется для других потоков.
* Потоки, которым нужен этот объект, находятся в ожидании разблокировки объекта
* Объект разблокируется по окончании работы метода.
* Помимо методов, можно создавать синхронизированные блоки кода:
* synchronized (ссылка_на_объект){блок_кода}
* Ссылка_на_объект определяет, какой объект в блоке должен быть синхронизирован. При поручении управления такому блоку, ни
* один поток не получит доступ к этому объекту, пока не выполнится синхронизированный блок.
* */

public class JavaMultiThreading {
    public static void main(String args[]) {  //метод main - это основной поток)
        int count=0;
        /*Thread thisThread = Thread.currentThread(); //метод currentThread выводит информацию о потоке, в данном случае о main.
        System.out.println(thisThread); //[main,5,main] - имя потока, его приоритет, и имя его группы соответственно.*/
        /*1-я Программа - тест Многопоточности и разных методов класса Thread*/
   /*     System.out.println("Запуск потока main");
        JavaNewThreadImpRunnable newThread = new JavaNewThreadImpRunnable(); //объект класса, имплементирующего Runnable
        Thread newThrd = new Thread(newThread, "thrdName"); // создание объекта потока и присвоение ему имени
        JavaNewThreadRunnable2 new2Thread = new JavaNewThreadRunnable2();
        Thread newThrd2 = new Thread(new2Thread, "thrd2Name");
        newThrd.start();// запуск потока
        newThrd2.start();
        System.out.println(newThrd.getName());// выдает имя потока, присвоенного нами, в нашем случае выдает thrdName
        System.out.println(newThrd2.getName());
        try{
            newThrd.join();
            System.out.println("Поток присоединен ");
            newThrd2.join();
            System.out.println("Поток 2 присоединен ");
            for (int i = 0; i < 100000; i++) {
                Thread.sleep(150);
                count++;
                System.out.println("Цикл "+count);
            }
        } catch (InterruptedException iau){
            System.out.println("Хана потоку((((");
        } //пока порожденный поток жив, основной будет выполняться повторно, в нашем случае,
        //при заданных временах простоя 150мс для основного и 500 для порожденного, основной выполняется 2 раза, т.е не 20 раз
        //прибавляет счетчик, а 40.*/
   /*2-я программа: тест выделения времени ЦП в зависимости от приоритетов потоков*/
   /*     PriorityThread thr1 = new PriorityThread("High Priority");
        PriorityThread thr2 = new PriorityThread("Low Priority");
        thr1.thrd.setPriority(7);
        thr2.thrd.setPriority(3);
        thr1.thrd.start();
        thr2.thrd.start();
        try{
            thr1.thrd.join();
            thr2.thrd.join();
        } catch (Exception da ){
            System.out.println("Че то не то");}
        System.out.println("\nCount HP" + thr1.count);
        System.out.println("\nCount LP" + thr2.count);*/
    }
}
