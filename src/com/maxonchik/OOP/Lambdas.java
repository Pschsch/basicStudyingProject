package com.maxonchik.OOP;
/*Класс с информацией о лямбда-выражениях и функциональных интерфейсах
* ************************************************************************************************************************************
* Лямбда-выражения были введены по принципу: другие ввели, и мы введем!)
* ************************************************************************************************************************************
* Основу лямбда-выражений составляют 2 конструкции: само выражение и функциональный интерфейс.
* Лямбда выражение - это анонимированный, т.е неименованный метод. Однако, сам этот метод никогда не выполняется. Он лишь позволяет
* назначить реализацию кода метода из функционального интерфейса. По сути, это некая форма анонимного класса. В отношении лямбд
* применяют термин "замыкание".
* Функциональный интерфейс - это интерфейс, содержащий в себе только один абстрактный метод. Обычно такой метод предполагает непосред-
* ственное назначение интерфейса. Например, интерфейс Runnable - функциональный интерфейс, так как содержит только один метод - run().
* Эти интерфейсы относят еще к типу Single Abstract Method(SAM). Важно значть, что при реализации функциональным интерфейсом открытых
* методов класса Object не лишают их статуса функционального интерфейса, так как при его реализации, экземпляр, реализующий этот интер-
* фейс автоматически использует методы класса Object.
* Синтаксис лямбд:
* Обозначается оператором-стрелкой: ->. Этот оператор разделяет лямбда-выражение на 2 части: в левой части - параметры выражения,
* во второй - его реализация. Существует 2 разновидности тел лямбд - одиночное и блочное. Одиночное состоит из одного выражения
* Блочное из блока кода.
* Простейший пример лямбда-выражения:
* () -> 98.6  // Данное  выражение вычисляет значение 98.6
* Подразумевается, что выражение возвращает параметр double, соответсвенно это выражение эквивалентно:
* double Method(){return 98.6;}
* Лямбда-выражение, разумеется, не обладает именем по определению.
* Также, в лямбда-выражениях можно использовать другие методы, например:
* () -> Math.random() * 100 // Данное выражение вычисляет произведение псевдослучайного числа метода random класса Math и 100.
* Если нужно лямбда-выражение с параметрами, они указываются слева:
* (n) -> 10.0/n
* Часто, параметр можно не указывтаь явно, если он легко устанавливается из контекста.
* В качестве возвращаемого типа, в лямбда-выражении может использоваться любой действительный тип:
* (n) -> (n%2)==0  //возвращает boolean
* Если передаваемый параметр один, то заключать в скобки его не обязательно:
* n ->(n%2)==0 //То же самое выражение
* Функциональные интерфейсы:
* По умолчанию метод является абстрактным, если он не подразумевает никакой реализации. Функциональный интерфейс содерижт только
* один абстрактный метод. Пример:
* interface FunctionalExample{
* int getInt(); //функция интерфейса
* }
* getInt никак не реализуется, следовательно - абстрактный, а так как интерфейс содержит только его, следовательно интерфейс является
* функциональным, и его функция определна как getInt().
* Лямбда-выражения определяют реализацию абсрактного метода определнного функциональным интерфейсом. Этот интерфейс определяет целевой
* тип, в контексте которого используется лямбда-выражение. Простейший пример - присвоение лямбды ссылке на интерфейс, пример в
* LambdaEx:
* Ссылку на функциональный интерфейс можно сразу проинициализировать лямбда-выражением:
* Возвращаемый тип лямбды должен строго согласовываться с типом метода из функционального интерфейса.
* При использовании лямбда-выражения в контексте целевого типа, создается объект класса, реализующего функциональный интерфейс.
* По сути, это средство преобразования сегмента кода в объект. Для того, чтобы работать с результатом лямбды, необходимо вызвать
* метод функционального интерфейса, пример в lambdaex:
* Если лямбда-выражение принимает параметры, то абстрактный метод также должен принимать теже самые параметры.
* Чтобы реализовать несколько параметров в лямбда-выражении, параметры прописываются через запятую. Если требуется привести тип
* одной из переменной в лямбда выражении, то типы других переменных также должны быть указаны явно.
* Вся эта информация выше относится к одиночным лямбда-выражениям. Есть еще и блочные
* ***********************************************************************************************************************************
* Блочные лямбда-выражения:
* Блочные лямбды по способу объявления не отличаюстя от обычных блоков кода. Достаточно заключить в фигурные скобки, пример в LambdaEx
* Обобщенные функциональные интерфейсы:
* Лямбда-выражение не может быть обобщенным, так как не может опрделять типы параметров. Особая ценность обобщенных функциональных ин
* терфейсов заключается в том, что нет нужды определять несколько интерфейсов для работы с разными типами данных, в том случае,
* если эти интерфейсы имеют одинаковые абстрактные методы: пример:
* interface SomeI<T>{
* boolean meth(T n, T m);
* }
* То есть, с помощью данного интерфейса мы можем работать как с числовыми объектами, так, например, и со строками и так далее.
* Лямбда-выражения можно передавать в качестве аргументов. Допустим, лямбда выражение вызывает какой-либо метод, чтобы не вызывать
* каждый раз этот метод, можно просто передать ссылку на лямбда-выражение как аргумент.
* Лямбда-выражения можно применять не только в контексах инициализации, присваивания и передачи аргументов, но и при приведении типов,
* в тернарном операторе, опреаторе return и в самих лямбдах.
* Захват переменных: При использвоании лямбды в классе, содержащим локальную переменную, для лямбды она неявно приобретает статус
* final. При попытке изменить эту переменную в лямбде, вылезет ошибка. Не допускается использование переменных, подвергающихся
* изменения в процессе выполнения программы.
* Исключения в лямбдах: если лямбда генерирует исключение, то в абстрактном методе через throws должно быть это исключение прописано.
* ССылки на методы:
* Ссылки на методы связаны непосредственно с целевым типом. Использование ссылок на методы позволяет не выполнять их, а сразу выволить
* результат их выполнения при определенном значении из абстрактного метода.
* Ссылки на методы - это те же лямбды. Ссылка на метод на то и ссылка: сам метод не выполняется, он лишь передается методу
* функционального интерфейса, главное чтобы совпадали целевые типы метода ФИ и метода, переданного по ссылке.
*
* Ссылки на статические методы:
* общий синтаксис:
* имя_класса::имя_метода  - :: новый разделитель в JDK 8.
* Использование ссылки на метод в купе с ссылкой на класс, который связан с функциональным интерфейсом.
* Ссылки на методы экземпляров классов:
* имя_объекта::имя_метода
* ССылки на конструкторы:
* имя_класса::new
* Сущетсвуют уже предопределнные функциональные интерфейсы, содержащиеся в пакете java.util.function
* UnaryOperator<T> - Применение унарной операции к объекту типа Т и возврат значения типа Т. Метод apply()
* BinaryOperator<T> - бинарная операция к двум объектам типа Т. Метод также apply()
* Consumer<T> - Применение опреации, ассоциированной с объектом Т. Метод accept()
* Supplier<T> - геттер объекта T. Метод get()
* Function<T, R> - Применение операции к Т и возврат R. Метод apply()
* Predicate<T> - Определяет, удовлетворяет ли объект Т некоторому ограничению. Возвращает булеан
*
*
* */

public class Lambdas { //Обход ограничения на изменение переменной внешнего класса анонимным классом
    private static void incr(Integer i){
        i+=1;
    }
    public static void main(String args[]) {
 Integer i = 0;
 Runnable r = new Runnable() {
     @Override
     public void run() {
        Lambdas.incr(i);
     }
 };

    }
}
