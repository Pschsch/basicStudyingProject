package com.maxonchik.OOP;

import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.NavigableSet;
import java.util.Optional;
import java.util.Properties;
import java.util.Random;
import java.util.RandomAccess;
import java.util.SortedSet;
import java.util.TreeSet;

/**********************************В этом классе вся информация о пакете java.util****************************************************/
/*Если java.lang. это мозг, то java.util это руки и ноги.
* Этот важный пакет предоставляет большой выбор классов и интерфейсов для крайне большого функционала. Например, генерация псевдослучайных
* чисел, управление датой и временем, просмтор событий, манипулирование набором битов, синтаксисческий анализ строк, обработка
* форматированных данных. в java.util входит одно из самых важных составляющих языка Java - коллекции Collections Framework.
* Этой составляющей ОБЯЗАТЕЛЬНО ВЛАДЕТЬ НА 100%!!! Этот набор представляет собой сложную иерархию классов и интерфейсов, реализующий
* управление группами объектов. Этот пакет является самым объемным в Java.
* Классы:
* AbstractCollection, AbstractList, AbstractMap, AbstractQueue, AbstractSequentialList, AbstractSet, ArrayDeque, ArrayList, Arrays
* Base64, BitSet, Calendar, Collections, Currency, Date, Dictionary, FormattableFlags, Formatter, GregorianCalendar, HashMap, HashSet
* Hashtable, IdentityHashMap, IntSummaryStatistics, LinkedHashMap, LinkedHashSet, LinkedList, ListResourceBundle, Locale
* LongSummaryStatistics и пр..(их слишком много))
* Часть 1: Коллекции:
* Коллекции были добавлены в J2SE 1.2 (JDK 2). Изначально, классы для работы со структурами данных имели сильно разное применение
* для того, чтобы их можно было объединить на одной основе. Эту проблему и решают коллекции. Каркас коллекций решает следующие
* задачи: 1)Изначально, по задумке, обеспечение высокой производительности. Основные коллекции из пакета (динамические массивы,
* связные списки, деревья и хеш-таблцы) отличаются очень высокой эффективностью. Программировать один из таких механизмов
* структур данных приходится крайне редко 2) Единообразное функционирование коллекций с высокой степенью взаимодействия.
* 3) Допуск простого расширения и адаптиции. Весь каркас коллекций построен на едином наборе стандартных интерфейсов.
* Некоторые стандратные реализации можно использовать в сыром виде: например LinkedSet, TreeSet, HashSet). JCF обеспечивает
* обширный простор для реализации собственных коллекций.
* Фреймворк коллекций содержит набор алгоритмов. Алгоритмы составляют другую важную часть коллекций. Они реализованы в виде
* статических методов в классе Collections. Алгоритмы доступны всем коллекциям, а также позволяют манипулировать коллекциями.
* Iterator - интерфейс итератора. Итератор стандартизирует поочередный доступ к элементам коллекций. Итератора представляет способ
* перебора содержимого коллекций. Все коллекции перебираются на основе итераторов, наследуемых от Iterator, т.е любая коллекция в JCF
 * обрабатывается почти одинаковым кодом с помощью методов из этого интерфейса.
* В JDK 8 был внедрен новый итератор - сплитератор, или итератор-разделитель. Сплитератор поддерживает параллельную итерацию коллекций
* Эти итераторы определены в интерфейсе Spliterator и его интерфейсах-наследниках, поддерживающих примитивные типы. Также,
* в JDK 8 были внедрены интерфейсы итераторов, работающих с примитивами: PrimitiveIterator и PrimitiveIterator.OfDouble
* Помимо коллекций, JCF содержит отображения - это пары ключ-значение. Отображения не являются коллекциями, но можно из них
* получить представление коллекции. Такое представление содержит элементы отображения в коллекции. Следовательно, его можно
* будет обрабатывать как коллекцию. Старые классы структур данных остались в Java до сих пор, однако это не делает их нерекомендованными
* так как они оптимизированы под JCF.
* Изменения, начиная с JDK 5 : добавление for-each, дженериков и автоупаковки повлияли и на коллекции. Они были переделаны, исходя
* из этих нововведений. Обобщения, в принципе, коренным образом изменили структуру коллекций.
* Все коллекции в Java являются обобщенными. Изначально, коллекции ссылались на объекты типа Object, что потеницально приводило
* к несовместимости типов. Благодаря дженерикам, можно указать явный тип данных и избежать типовой несовместимости.
* Благодаря автоупаковке, в коллекциях можно условно хранить примитивные типы данных в виде ссылок на них. Но непосредственно значения
* сохранять нельзя, так как коллекции работают только с объектами.
* Благодаря реализации Iterable, колеекции можно обрабатывать с помощью цикла for-each. Раньше, для перебора нужно было использовать
* итератор, организуя цикл вручную. Итераторы изредка еще применяются для особых целей, но в большинстве случаев обработки на основе
* for-each достаточно.
* Интерфейсы коллекций: коллекции включают в себя несколько основных интерфейсов: Collection, Deque, List, NavigableSet, Queue,
* Set, SortedSet, RandomAccess, Iterator, Spliterator,Comparator, ListIterator. Все классы коллекций базируются на этих интерфейсах
* и на основе этих интерфейсов можно создавать собственные коллекции. Подробнее ниже
* Некоторые методы интерфейсов коллекций являются необязательными для большего удобства использования коллекций. Необязательные
* методы позволяют изменять коллекции.
* Все встроенные коллекции в Java являются изменяемыми, т.е поддерживают методы для изменяемых коллекций. Неизменяемые, при попытке
* использовтаь их с необяхательными методами генерируют UnsuppotedOperationException.
* ************************************************************************************************************************************
* Интерфейсы JCF:
* 1)Collection - родительский интерфейс всех интерфейсов коллекций. На этом интерфейсе базируется вся структура JCF.
* interface Collection<T> - T - тип объектов, которые будет содержать коллекция. Collection расширяет Iterable, что позволяет обрабатывать
* все коллекции с помощью for-each. При попытке ввести несовместимый тип в коллекцию, генерируется ClassCastException. Если ввести
* null в коллекцию, возникнет NPE. IllegalArgumentException генерируется при неверном аргументе. IllegalStateException генерируется
* при попытке ввести новый элемент в заполненную коллекцию фиксированной длины. Методы интерфейса Collection:
* 1)boolean add(T obj) - метод добавляет элемент в коллекцию, возвращает true при успешном добавлении, если произвести попытку
* добавить такой же элемент в коллекцию, которые не допускают дублирований, вернет значение false.
* 2)boolean addAll(Collection<? extends T> c) - вводит все элементы заданной коллекции c в вызывающую коллекцию. Вернет true, если
* коллекция успешно изменена.
* 3)void clear() - очищает полностью вызывающую коллекцию
* 4)boolean contains(Object obj) - возвращает true, если вызывающая коллекция содержит объект obj
* 5)boolean containsAll(Collection <?> c) - возвращает true, если вызывающая коллекция содержит все элементы переданной коллекции
* 6)boolean equals(Object obj) - тут понятно
* 7)Iterator<T> iterator() - возвращает итератор для вызывающей коллекции
* 8)default Stream<E> parallelStream() - возвращает поток ввода-вывода, который в качестве своего источника использует
* вызывающую коллекцию. В этом потоке поддерживаются параллельные операции ввода вывода, если это вообще возможно
* 9)boolean remove(Object obj) - удаляет один экзепляр объекта из вызывающей коллекции. Возвращает true, если удаление успешно
* 10)boolean removeAll(Collection <?> c) - удаляет все элементы переаддной в качестве параметра коллекции в вызывающей коллекции.
* true если удаление хотя бы одного элемента прошло успешно(т.е коллекция изменилась), иначе false
* 11)default boolean removeIf(Predicate<? super T> pred) - удаляет элементы из коллекции, удовлетворяющие условию, заданному предикатом
* 12)boolean retainAll(Collection <?> c) - удаляет все элементы, кроме элементов коллекции c. Возвращает true, если коллекция из-
* меняется. Иначе false
* 13)int size() - возвращает кол-во элементов коллекции
* 14)default Spliterator<T> spliterator() - возвращает сплитератор вызывающей коллекции
* 15)default Stream<E> stream() - то же, что и parallelStream(), только здесь поддерживаются последовательные операции ввода-вывода
* 16)Object[] toArray() - возвращает коллекцию в виде массива Object!!!
* 17)<T> T[] toArray(T array[]) - возвращает массив из коллекции. Если заданный массив меньше коллекции, то массив увеличивается
* до нужной длины. Если больше, то оставшиеся ячейки массива заполняются null-ом. Если хоть один элемент коллекции не является
* типом массива, то генерируется ArrayStoreException
* Объекты вводятся в коллекцию методом add(). Однако, нужно помнить про тип данных, add добавляет элемент типа <E>, следовательно
* коллекция дожна быть этого же параметра типа. В методе removeIf используется функциональный интерфейс Predicate<? super T>,
* объект которого должен быть типа T или его суперклассом. Методы работы с коллекциями как с массивами имеют очень востребованное
* применение.
* 2)Интерфейс List:
* List наследуется от Collection. Определяет списочную последовательность элементов в коллекциях. Элементы могут быть введены или извлечены
* по индексу их позиции в списке начиная с нуля. Список может содержать повторяющиеся элементы. Объявление:
* interface List<T> - где Т - тип помещаемых в список объектов.
* Для List(и вообще для всех интерфейсов коллекций) доступнеы методы интерфейса Collection, но они имеют еще и ряд своих методов.
* Исключения при использовании методов генерируются те же самые, что и для интерфейса Collection: UnsupportedOperationException
* если коллекция не может быть изменена, NPE - если null обавляется, ClassCastException - вод несовместимого типа объекта
* IndexOutOfBoundsException - при попытке добавить или вывести из несуществующего индекса, IllegalArgumentException - при попытке
* использования недопустимого аргумента.
* Методы интерфейса List(некоторые методы переопределены из интерфейса Collection){
* 1)void add(int index, T obj) - добавляет объект на заданную позицию. Любые элементы, записанные ранее, смещаются к началу списка относительно
* index, что говорит о том, что элементы списка не перезаписываются.
* 2)boolean addAll(int index, Collection<? extends T> c) - выводит элементы коллекции с в вызывающий список, начиная с заданного
* индекса. Введенные ранее элементы смещаются к началу списка. Возращает true, если коллекция изменена.
* 3)T get(int index) - возвращает объект из списка по указанному индексу
* 4)int indexOf(Object obj) - возвращает индекс первого вхождения заданного объекта в списке. Если отстутствует, возвращает -1.
* 5)int lastIndexOf(Object obj) - возвращает послденее вхождение, если нет - -1.
* 6)ListIterator<T> listIterator() -  возвращает итератор для обхода элементов с начала списка
* 7)ListIterator<T> listIterator(int index) - то же самое, только с конкретного индекса
* 8)T remove(int index) - удаляет элемент из вызывающего списка по заданному индексу и возвращает его. Измененный список уплотняется,
* то есть происходит сдвиг на 1 позицию влево
* 9)default void replaceAll(UnaryOperator<E> opobj) - обновляет каждый элемент списка значением, полученным из функции opobj.
* 10)T set(int index, T obj) - Присваивает заданный объект элементу, находящемуся в списке на позиции по указанному индексу.
* Возвращает прежнее значение
* 11)default void sort(Comparator<? super E> comp) - сортирует список, используя заданный компаратор
* 12)List<E> subList(int begin, int end) - возвращает список, содержащий элементы от begin до end-1 из вызывающего списка
* Интерфейс Set: - множество. Расширяет Collection. Определяет поведение коллекций, не допускающих дублирование элементов.
* Т.е метод add при попытке ввести дублирующий элемент вернет значение false. Set не содержит дополнительных методов. Является
* обобщенным, объявляется следующим образом:
* interface Set<E>
* Интерфейс SortedSet:
* SortedSet расширяет Set  множество в порядке возврастания:
* interface SortedSet<T> extends Set
* Методы:
* T first() -возвращает первый элемент отсортирвоанного множества
* Comparator <? super T> comparator() - возвращается компаратор для отсортированного множества, null, если выбирается естественный
* порядок множества
* SortedSet<T> headSet(T end) - возвращает SortedSet, содержащий элементы вызывающего множества, от наччала множества до элемента
* end. Ссылки на элементы сохраняются и в вызывающем сортированном множестве.
* T last() - вовзращается последний элемент множества
* SortedSet<T> subSet(T begin, T end) - возвращает подмножество из вызывающего множества от begin до end
* SortedSet<T> tailSet(T begin) - метод, обратный headSet
* }
* Интерфейс NavigableSet - наследуется от SortedSet. Извлечение элементов из этого множества определяется исходя из наиболее точного
* совпадения с заданым элементом множества.
* interface NavigableSet<T> extends SortedSet<T>. Методы этого интерфейса, помимо методов из суперинтерфейсов:
* T ceiling(T obj) - возвращает из множества наименьший элемент по критерию элемент>=obj. Если такого нет, возвращается null
* Iterator<T> descendingIterator() - возвращает обратный итератор для множества
* NavigableSet<T> descendingSet() - возвращает инверсированное множество по отношению к вызывающему множеству
* T floor(T obj) - обратный метод ceiling - возвращает наибольший элемент по критерию элемент<=obj
* NavigableSet<T> headSet(E max, boolean additional) - Возвращает множество, содержащее все элементы от начала до элемента, заданного
* как максимум. Если additional = true, то включая и этот элемент
* T higher(T obj) - выполняет поиск в множестве объект по критерию элемент>obj, если такого нет - то null
* T lower(T obj) - поиск наименьшего элемента элемент<obj, если такого нет - null
* T pollFirst() - возвращает самый меньший элемент множества, попутно удаляя его из этого множества(этот элемент первый, так как
* множество отсортировано)
* T pollLast() - аналогично, только для большего элемента множества
* NavigableSet<T> subSet(T up, boolean upAdd, T bottom, Boolean bottomAdd) - возвращает подмножество в указанных границах,
* при значении обоих boolean true, верхняя и нижняя граница включаются в возвращаемое подмножество.
* NavigableSet<T> tailSet(T bootom, boolean bottomAdd) - возвращает подмножество, включающее в себя все элементы, выше нижней
* границы, ели bottomAdd - true, то включает в себя нижнюю границу
* Интерфейс Queue: интерфейс очереди. Действует по принципу FIFO(first in - first out). Очереди бывают разные:
* interface Queue<T>
* T - тип объектов, находящихся в очереди. Интерфейс наследуется от Collection
* Методы:
* T element() - возвращает элемент из головы очереди. Если очередь содержит 1,2,3,4,5 в порядке мест, то вернется 1. Возвращаемый
* элемент не удаляется из очереди, генерирует EXception при пустой очереди
* boolean offer(T obj) - пытается ввести заданный объект в очередь, возвращает true, если объект успешно добавлен
* T peak() - возвращает элемент из головы очереди, если очередь пуста - то null. Возвращаемый элемент не удаляется из очереди
* T poll() - возвращает элемент из головы очереди и удаляет его. Если очередь пуста, то возвращается null
* T remove() - озвращает удаленный из очереди элемент, генерирует NoSuchElementException при пустой очереди
* Этот интерфейс имеет ряд особенностей: 1)Работа с элементами осуществялется только из головы очереди. 2) Очереди зачастую имеют
* фиксирвоанную длину
* Интерфейс Dequeue: наследуется от Queue, определяет поведение двусторонних очередей. Такие очереди работают одновременно как
* стек и как очередь. Методы этого интерфейса:
* 1)void addFirst(T obj) - вводит заданный объект в голову двусторонней очереди. Если очередь заполнена, генерируется
* IllegalStateException
* 2)void addLast(T obj) - вводит заданный объект в хвост двусторонней очереди. Если заполнена - llegalStateexception
* 3)Iterator<T> descendingIterator() - обратный итератор очереди от хвоста к голове
* 4)T getFirst() - возвращает первый элемент двусторонней очереди
* 5)Е getLast() - возвращает последний элемент двусторонней очереди. Оба метода, в случае пустой очереди бросают
* NoSuchElementException
* 6)boolean offerFirst(T obj) и boolean offerLast(T obj) - вводят объект в голвоу и хвост двусторонней очереди соответственно
* при изменении очереди возвращают true
* 7)T peekFirst и T peekLast() - возвращает элемент из головы и хвоста двусторонней очереди соответсвенно. Если очереди пусты, то
* возвращает null
* 8)T pollFirst и T pollLast() - возвращает элемент из головы и хвоста очереди, попутно удаляя его. При пустой очереди -
* NoSuchElementException
* 9)T pop() - то же, что и pollFirst
* 10)void push(T obj) - вводит объект в голвоу двусторонней очереди
* 11)T removeFirst и T removeLast - возвращает удаленный из головы и хвоста соответственно очереди объект
* 12)boolean removeFirstOccurence и removeLastOccurence - удаляет первый и последний экземпляр относительно головы очереди
* соответсвенно. true - если очередь изменена. push() и pop() методы нужны для функционирования очереди как стека.
* **********************************************************************************************************************************
* Интерфейсы JCF разобрали, перейдем к классам: классов гораааааздо больше)))
* JCF предоставляет как стандартные готовые классы коллекций, так и абстрактные классы, являющиеся отправной точкой для создания
* собственных коллекций. Как правило, классы коллекций не синхронизованны, но можно получить их синхронизованные варианты.
* Будем пробовать применять каждый конкретный класс коллекций.
* Класс ArrayList: наследуется от AbstractList и имплементирует интерфейс List.
* class ArrayList<T> extends AbstractList<T> implements <T>
* Этот класс поддерживает динамические массивы - массивы, которые растут по мере надобности. Это очень важна коллекция, так как
* позволяет работать с массивом неизвестной длины, когда заранее неизвестно, насоклько большой потребуется массив. По сути, класс
* представляет собой списочный массив объектных ссылок переменной длины. Изналаьный размер нужно задать, но если этого размера не
* будет хватать, то коллекция автоматом расширится. По мере удаления объектов, в целях экономии памяти, она может уменьшаться.
* Класс ArrayList имеет 3 конструктора:
* ArrayList() - пустой списочный массив
* ArrayList(Collection<? extends T> c) - списочный массив на основе заданной коллекции
* ArrayList(int size) - списочный массив заданного размера
* Заданный размер относится к базовому размеру, то есть он все равно может быть увеличен по мере ввода новых элементов
* Опробуем ArrayList
* По мере изменения его содержимого , массив динамически сокращается и увеличивается. При выводе содержимого через методы воода-вывода
* к нему автоматически применяется мтеод toString(). На практике это используется редко, зачастую для вывода соержимого испольузется
* кастомный ввод-вывод. Если заранее известно, то массив будет большим, то желательно сразу его увеличить методом ensureCapacity
* чтобы избежать падения производительности.
* Класс LinkedList: наследуется от AbstractSequentalList и реализует List, Queue, Dequeue. Это связный список:
* class LinkedList<E>
* 2 конструктора
* LinkedList() - пустой связный список
* LinkedList(Collection<? extends T> c) - связный список на основе коллекции с
* Связный список - структура данных, состоящяя из узлов(ячеек), которые содержат в себе данные и содержат ссылку на следующий узел
* Метод add вводит элементы в конец связного списка, как и метод addLast, поэтому, чтобы занести элемент в конкретный узел связного
* списка, нужно прописать индекс узла. Изменяются элементы с помощью методов get и set.
* Класс HashSet: наследуется от AbstractSet и реализует Set. Эта коллекция реализует хеш-множество. Хеш-таблица - таблица для хранения
* пар ключ-значения, ключи в которых представляют собой хеш-функцию. Для хранения данных в хеш-таблице применяется механизм хеширования
* где содержимое ключа служит для определения конкретного значения - это хеш-код. Далее хеш-код используется для идентификации
* объектов из хеш-таблицы. Преобразования ключа в хеш-код происходит автоматически.
* Конструкторы HashSet:
* HashSet()
* HashSet(Collection<? extends T> c)
* HashSet(int size)
* HashSet(int size, float coefficient)
* По умолчанию, емкость хеш-множества равна 16. Коэффициент заполнения определяет, насколько должно быть заполнено хеш-множество,
* прежде чем оно будет увеличено. По умолчанию, равен 0.75 . Данный класс не предоставляет своих доп.методов. Этот класс не гарантирует
* упорядоченности элементов, так как сам процесс хеширвоания этого не гарантирует. Для пролучения сортированных множеств лучше
* использовать TreeSet. Пример:
* Класс LinkedHashSet: расширяет HashSet. Гибрид связного списка и хеш-множества: поддерживается связный список элементов хеш-множества
* в том порядке, в котором они были ввведены. При обработке итератором такого множества, будет производиться обработка в том порядке,
* в котором элементы были введены. Поменяет хеш-множество в программе на связное хеш-множество
* Класс TreeSet: наследуется от AbstractSet и реализует NavigableSet. Коллекция реализуется в виде древовидного множества.
* В данном множестве, объекты записываются и отсортировываются по возрастанию(в верхушке дерева - наибольший элемент).
* Имеет 4 конструктора:
* TreeSet()
* TreeSet(SortedSet<E> ss)
* TreeSet(Comparator<? super E> comp) - передается компаратор, о них далее
* TreeSet(Collection <? extends E> c)
* Пример посмотрел, как работает, действительно, сортирует в порядке возрастания.
* Так как класс реализует навигационное множество, можно вывести подмножество из древовидного множества.
* Класс PriorityQueue: расширяет AbstractQueue и реализует Queue. Очередь по приоритетам. Первоначальная емкость - 11. Если не указан
* компаратор для очереди, испольузется компаратор по умолчанию для вводимого типа данных. По умолчанию, размещает компоненты по
* нарастающей. Но, предоставляя свой компаратор, можно задать свой алгоритм сортировки очереди.
* Класс ArrayDeque - готовая реализация двусторонней очереди на основе массива. Реализует Deque и наследуется от AbstractCollection
* Первоначальная емкость двусторонней очереди равна 16. Пример:
* Класс EnumSet - наследуется от AbstractSet и реализует Set. Служит для создания множества, применимого вместе с ключами перечислимого типа
* Методы позже:
* Доступ к коллекциям через итератор: итератор - это объект, реализующий Iterator или ListIterator. Этот объект позволяет перебрать
* все элементы коллекции чтобы, например, вывести их. Iterator позволяет реализовать циклы для перебора элементов, извлекая или
* удаляя из нее элементы. ListIterator расширяет Iterator и позволяет обходить списки в двух направлениях.
* Методы интерфейса Iterator:
* default void forEachRemaining(Consumer<? super E> deal) - выполняет заданное deal над каждым необработанным объектом из коллекции
* boolean hasNext() - возвращает true, если следующий элемент присутсвует в обрабатываемой коллекции(есть что обрабатывать)
* E next() - возвращает следующий элемент из коллекции, генерирует NoSuchElementException
* void remove() - удаляет текущий элемент из коллекции
* ListIterator
* void add(E obj) - вводит заданный элемент перед элементом, который д/б возвращен в результате последующего вызова next
* hasNext() и hasPrevious() - для обработки списков в двух направлениях
* void set(E obj) - присваивает заданный объект текущему элементу
* Итераторы хороши тогда, когда нужно видоизменять коллекцию при обработке и обрабатывать ее в обратном порядке. В другом
* случае, лучше воспользоваться for-each.
* Сплитераторы, или итераторы-разделители
* Внедрены в JDK 8 . Определяется в интерфейсе Spliterator. Данный интерфейс - улучшенная версия итератора, поддерживает паралельное
* итерацию разных частей коллекции.
* Одно из главных преимуществ коллекций в том, что в них можно сохранять , извлекать и обрабатывать объекты пользовательских классов.
* При этом программа получается очень короткой. Поскольку программировать вручную эти операции - трудозатраное действие, то эффективное
* использвоание коллекций - то что нужно в этом случае. Коллекции предлагают решения широкого круга задач.
* Интерфейс RandomAccess: этот интерфейс не содержит ничего, но обеспечивает эффективный произвольный доступ к элементам коллекций(лол)
* . Этот интерфейс реализуют ArrayList, Vector. RandomAccess - это маркерный интерфейс, все, точно)
* ***********************************************************************************************************************************
* Отображения -  это объекты типа Map и производные от него. отображения хранят данные по паре ключ-значение. Ключи и значения
* являются объектами. В одних отображениях допускаются пустые ключи и пустые значения, в других они не допускаются.
* Основные свойства отображений: они не реализуют Iterable и для них не существует итератора. Это печалька, но есть выход.
* Можно получить представление отображения в виде коллекции.
* Интерфейсы отображений: как и коллекции, отображения базируются на интерфейсах.
* Интерфейс Map: - карта. Отображает однозначные ключи на значения. Ключ - это объект, используемый для последующего извлечения данных.
* Задавая ключ и значение, можно размещать значение в отображении, представленном объектом типа Map. Сохранив значение по ключу, можно
* получить его обратно по этмоу же ключу. Синтаксис интерфейса Map:
* interface Map<K,V> - где К - тип ключей, V - тип значений
* Методы интерфейса Map:
* default V compute(K k, BiFunction<? super K, ? super V, ? extends V> func) - вызывает заданную функцию для построения нового значения
* При успешной операции, удаляет ранее существовавшее и возвращает новую пару ключ-значение. Если не успешно, то возвращает null
* void clear() - удаляет все пары ключ-значение вызывающего отображения
* boolean containsKey(Object k) - возвращает true, если ключ присутствует в отображении
* boolean containsValue(Object v) - true, если значение присутствует
* Set<Map.Entry<K,V>> entrySet() - переделывает Map.Entry в Set
* V get(Object k) - возвращает значение по ключу
* default V getOrDefault(Object k, V value) - если ключ есть, то вызывает значение по ключу, если нет, то значение, указанное в пара-
* метрах метода
* Set<K> keySet() - возвращает множество, содержащее все ключи вызывающего отображения.
* V put(K k, V v) - помещает значение с заданным ключом, возвращает значение, которое принадлжеало этому ключу до этого, если
* ключа не было - то null
* Основное применение карт сводится к методам get и put и методу entrySet для получения представления карты в виде множества
* Интерфейс SortedMap:
* Расширяет Map. Обеспечивает порядок ключей по возрастанию. Этот интерфейс позволяет получать подотображения с помощью
* методов: subMap(K begin, K end), tailMap(K begin), headMap(K end)
* Интерфейс NavigableMap: обеспечивает вывод значения по наиболее точному совпадению с ключом.
* Методы этого интерфейса схожи с методами интерфейса NavigableSet, также позволяют искать ключи по критериям.
* Интерфейс Map.Entry: этот интерфейс позволяет обращаться с отдельными записями в отображении. Множество, получаемое из метода
* entrySet() содержит в себе каждый элемент этого типа. Map.Entry, проще говоря, это поля карт, которые хранят праы ключ-значение
* Классы отображений:
* HashMap: используется хеш-таблица для хранения отображения. То же, что и HashSet, только для отображения
* TreeMap: реализует NavigableMap и наследуется от AbstractMap
* Древовидная карта. Сортируется с помощью заданного компаратора. TreeMap ортирует ключи по возрастанию
* LinkedHashMap: связный список элементов отображения в порядке добавления элементов в карту. Можно настроить так, что доступ будет
* проходить по элементам, к которым был осуществлен доступ послдений раз.
* Класс IdentityHashMap: не предназначен для общего применения.
* Класс EnumMap: то же, что и EnumSet, только для карты
* Компараторы: Компаратор определяет порядок сортирвоки элементов в коллекциях и отображениях. По умолчанию применяется естественный
* компаратор, сортирующий элементы по значениям: после A идет В, после 1 идет 2, и т.д. В Java, такое упорядочивание называется
* естественным упорядочиванием.
* Интерфейс Comparator<T> содержит 2 метода - compare() и equals(). Для того, чтобы изменить порядок сортировки элементов, эти
* методы переопределяются исходя из нужд. Но после выпуска JDK 8, компараторы были существенно доработаны:
* появился метод default Comparator reserved() - инвертирует компаратор, то есть компаратор начинает работаь обратно, апример. уде
* после 4 будет идти 3, после B будет идти А и так далее. Чтобы получить компаратор с естественным упорядочиванием, можно вызывтаь
* метод naturalOrder(). Существуеют методы nullFirst и nullLast, которые позволяют компаратору обрабатывать null. Если применен
* метод nullFirst, то null будут наименьшими. Интерфейс Comparator имеет метод thenComparing(). Очень важный метод, так как позволяет
* сравнивать вторые объекты при равенстве первых. Например, есть 2 названия: города и области. Если область одинакова, то выполняется
* упорядочивание городов: Пример: Краснодарский край  Краснодар
*                                 Краснодарский край  Курганинск
* Методу передается второй компаратор и выполняется в том случае, если первый компаратор выдал равенство.
* Метод comparing() - метод возвращает компаратор, получающий ключ для сравнения от функции, переданной методу в качестве параметра
* static <T, U extends Comparable<? super U>> Comparator<T> comparing(Function<? super T, ? extends U> getKey)
* Применение компараторов: для этого создается специальный класс компаратора, в котором переопределяются нужные методы, прописывается
* алгоритм сравнения и применяется в виде компаратора в коллекциях. Класс компаратора обязательно должен реализовывать Comparator.
* По умолчанию не принято переопределять методы equals и методы, внедренные вместе с JDK 8. Интерфейс Comparator помечен
* аннотацией @FunctionalInterface. Лямбда-выражением можно переопределять метод compare(). Метод equals, который в нем определен
* переопределен из класса Object, поэтому этот интерфейс может считаться функциональным. Компаратор с реализацией лямбда-выражением
* можно сразу передать коллекции в виде компратора.
* Алгоритмы коллекций: наверное, самое важное, что есть в коллекциях!. Все алгоритмы определены в классе Collections как статические
* методы. Списко этих алгоритмов:
* 1)<T> boolean addAll(Collection<? super T> c, T ... элементы) - вставляет заданные элементы в коллекцию с, возвращает true,
* если они были добавлены
* 2)<T> Queue<T>asLifoQueue(Deque<T> dq) - возвращает двустороннюю очередь как стек
* 3)<T> int binarySearch(List<? extends T> list, T val, Comparator<? super T> comp) - осуществляет бинарный поиск заданного значения
* в списке, упорядоченном в сответствии с заданным компаратором. Возвращает индекс заданного значения в списке, иначе -1.
* Алгоритм двоичного поиска осуществляется через деление списка пополам. Эффективен для отсортированного массива или списка. Его
* еще называют методом деления пополам. Нужное значение сравнивается со значением по середине массива, если равно, то поиск успешен,
* если нет, томассив делится пополам и поиск производится в той подовине, в зависимости от того, болше среднее значение  или меньше,
* если больше - то в правой половине, если меньше - в левой.
* 4)<E> Collection<E> checkedCollection(Collection<E> c, Class<E> f) - возвращает динамически типизируемое представление коллекции.
* 5)<E> List<E> checkedList(List<E> c, Class<E> f) - возвращает динамически типизируемое представление списка List.
* Методы необходимы для более безопасного типизирования коллекций, пример ниже:
* Т.е, коллекция может терять тип и принмать тупо объекты типа Object, соответсвенно необходимо динамически типизировать коллекции.
* Это больше преимущество, чем недостаток, так как позволяет хранить в коллекции объекты разных типов.
* static <E> Collection<E> checkedList(List<E> c, Class<E> f) - то же самое, только для списка.
* static<K, V> Map<K, V> checkedMap(Map<K, V> c, Class<K> тип_ключа, Class<V> тип_значения) - возвращает динамически типизируемое
* представление карты.
* Те же методы присутствуют для остальных видов коллекций и отображений.
* static<T> void copy(List<? super T> list1, List<? extends T> list2 ) - копирует элементы из спсика 2 в список 1.
* boolean disjoint(Collection <?> a, Collection<?> b) - Возвращает true, если коллекции не содержат общих элементов
* Enumeration<T> emptyEnumeration() - возвращает пустое перечисление
* Iterator<T> emptyIterator() - озвращает пустой итератор
* static <T> List<T> emptyList() - возвращает пустой список
* также и для других коллекций и карт есть методы возвращающие их пустые экземпляры
* static<T> void fill(List<? super T>, T obj) - заполняет все ячейки списка этим объектом
* static int frequency(Collection<?> c, Object obj) - подсчитывает крличесвто переданных объектов в заданной коллекции
* int indexofSubList - возвращает первое вхождение заданного подсписка в списке
* int lastIndexOfSubList - возвращает последний индекс заданного подсписка
* остальное дописать позже:
* Класс Arrays - класс для более удобного обращения с массивами. Восполняет пробел между коллекциями и массивами.
* Основной метод asList() - возвращает массив в виде списка. Список ссылается на ту же ячейку памяти, что и массив. По сути, преобра-
* зовывает массив в коллекцию. Также, в этом классе переопределны методы бинарного поиска для разных типов массивов. Метод copyOf -
* возвращает копию массива разных примитивных типов и типа Object
* copyOfRange - копирует массив в заданных пределах.
* deepEquals() - метод сравнения многомерных массивов
* fill() - заполняет массив заданным объектом или примитивом
* sort() - сортирует элементы массива по возрастанию
* Остальное дописать позже:
* Все методы являются статическими.
* Унаследованные классы и интерфейсы: здесь поясняются классы и интерфейсы, которые были внедрены до коллекций:
* Эти классы - синхронизированы, в большинстве сулчаев не испольузются, так как есть их более современные аналоги
* Но, тем не менее, они были переделаны под обобщнные версии.
* Интерфейс Enumeration: ранняя версия интерфейса Iterator. Этот интерфейс не рекомендуется к употреблению(это как дешевый самогон)
* Но, он используется в некоторых классах и методах, поэтому он также был переделан под обобщенную версию:
* interface Enumeration <T>
* Класс Vector: вектор он же динамический массив. Ранняя версия ArrayList. Также не рекомендуется.
* Класс Stack - простой стек. В качестве стека лучше использовать двустороннюю очередь ArrayDeque, хотя , в принципе, его тоже можно
* использовать.
* Класс Dictionary: словарь. Аналогичен карте. Абстрактный класс. Не рекомендуется для использования. Лучше реализовать Map.
* Класс HashTable: хеш-таблица. Наследуется от Dictionary. Но, был переделан под реализацию Map. Можно использовать, эта хеш-таблица
* такая же, как и хеш-карта, но синхронизирована. Хеш-таблицу также можно представить в виде множества, так как она реализует
* интерфейс Map.
* Класс Properties: свойства. Наследуется от HashTable. Properties поддерживает ключи-значения только строкового типа. Единственный
* унаследованный класс, который имеет право на активное использование. Простейший пример использования свойств: метод getProperties()
* класса System. Класс Properties содержит дефолтную переменную экземпляра эого класса defaults. Эта переменная просто объявлена
* как protected. Эта переменная используется в одном из конструкторов этого класса для задания свойств по умолчанию.
* Единственный косяк, Properties содержит метод устаревший метод save(), но он помечен как deprecated, так что все хорошо
* Методы класса Properties:
* getProperty(String key) - возвращает свойство по ключу, если нет - то null
* getProperty(String key, String defaultValue) - озвращает свойство по ключу, если его нет, то заданное свойство
* void list(PrintStream pr) - передает список свойств потоку вывода PrintStream
* void list(PrintWriter pw) - то же самое, только символьному поткоу вывода
* void load(InputStream is) throws IOException - выводит список свойств из потока ввода
* void store(OutputStream os, String description) throws IOException - вызывает свойство с выводм описания в заданном потоке вывода
* void storeToXML() - аналогично, тольков ыводит в XML-документ, который связан с потоком вывода
* Класс Properties позволяет создавать иерархию свойств, посредством передачи одного объекта свойств другому.
* Заключение: коллекции - это важная часть структуры Java, позволяющая решать самые разнообразные задачи, от мелких программ до
* крупных проектов. Обладать навыками работы с коллекциями обязан каждый опыытный программист на Java.
* **********************************************************************************************************************************
* Прочие классы из пакета java.util
* Класс StringTokenizer. Данный класс является лексическим анализатором, его еще называют сканнером. Синтаксический анализ
* подразумевает разделение строки на лексемы, которые в определенной последовательности могут передать определенное семантическое значение.
* Чтобы воспользоваться этим классом, нужно указать входную символьную строку, содержащую разделители. Разделители - символы,
* разделяющие лексемы. Набор разделителей по умолчанию состоит из пробельных символов, символа табуляции, перевода строки и переноса
* каретки. По сути, просто убирает токены и разделяет части между токенами на отдельные строки
* 3 конструктора:
* StringTokenizer(String str)
* StringTokenizer(String str, String tokens)
* StringTokenizer(String str, String tokens, boolean tokenAsLexeme)
* Методы: int countTokens - считает количество лексем, которые осталось вывести
* boolean hasMoreElements() - возвращает true, если в символьной строке остается один или больше лексем
* boolean hasMoreTokens() - то же самое
* Object nextElement() - озвращает следующую лексему в виде Object
* String nextToken() - возвращает лексему в виде строки
* Класс BitSet - битовый вектор. Содержит биты в виде логических значений. 0 -false, 1 - true
* Позже написать методы, пока просто знать, что такой класс есть
* Класс Optional: позволяет избежать NPE. Звучит круто.
* class Optional <T>
* Экземпляр этого класса может быть пустым или содержать объект типа T. Конструкторы этого класса - приватные.
* Основными методами класса Optional являются isPresent() и get(). isPresent() возвращает true, если элемент в оъекте Optional
* присутствует. Optional позволяет существенно сократить код , который обычно забит проверками на null.
* Cуществует всего три категории Optional:
Optional.of — возвращает Optional-объект.
Optional.ofNullable -возвращает Optional-объект, а если нет дженерик-объекта, возвращает пустой Optional-объект.
Optional.empty — возвращает пустой Optional-объект.
Итог такой: Optional нужен там, где null по-любому не должно быть, и позволит сократить код проверками на null. Но, Optional
замедляет работу программы, поэтмоу по ситуации.
* Класс Date: инкапсулирует текущую дату и время. 2 конструктора Date() и Date(long ms). Методы класса Date:
* Содержит много deprecated, здесь только рекомендованные:
* boolean after(Date date) - true, если вызывающий объект содержит более позднюю дату, чем введенную
* boolean before(Date date) - возвращает true, если указанный объект содержит более раннюю дату
* int compareTo(Date date) - 1 если дата больше, 0 если равна, -1 если дата раньше
* long getTime() - количество миллисекунд с 1 января 1970г.
* void setTime(long time) - устанавливает время в миллисекундах с 1 января 1970г.
* Класс Calendar - абстрактный класс, позволяющий преобразовывать время в миллисекундах в целый ряд составляющих.
* Основная функция этого класса - обеспечивание своим подклассам возможности удобного предоставления информации о составляющих даты.
* Конструктор закрыт, через getInstance() идет получение экземпляра календаря. Определен ряд констант, представляющих разные
* фрагменты даты и времени: DAY MONTH YEAR DATE и т.д.(можно посмотреть в исходнике класса)
* Через методы get и set идет работа с календарем.
* GregorianCalendar - позволяет созщдать экземляр григорианского календаря с конкртеными значениями даты и времени.
* Class TimeZone - класс для работы с часовыми поясами
* Locale - класс для создания объектов, каждый из которых описывает географический или культурный регион.
* Класс Locale поддерживает стандарты региональных языков и дескрипторы для идентификации языков.
* Класс Random - предназначен для генерации псевдослучайных чисел. Они псевдослучайные, так как представляют собой сложные
* распределенные последовательности. Включает в себя 2 конструктора:
* Random() - простой Random, инициализация с однозначного числа
* Random(long beginCount) - инициализация начальным числом
* Если начальное число одинаковое, то последовательность будет тоже одинаковая.
* Классы Observable и Observe рассмотрим, когда будем изучать ReactiveXJava
* Timer и TimerTask - позволяют планировать запуск задания в определенный момент времени
* Currency - сведения о денежной единице
* Formatter - инкапсулирует форматированный вывод данных. Для форматирования данных, нужно создать объект этого класса
* Formatter() этот класс требует тщательного рассмотрения, не забыть за него! К нему в дополнение идет Scanner, тоже рассмотрим позже
*
*
*
*
*
*
*
*
*
*
*
*
*
* */
public class JavaUtil{
    public static void main(String args[]){
        ArrayList<Integer> intoviySpisochniyMassiv = new ArrayList<>(10);
        System.out.println(intoviySpisochniyMassiv.size()); //размер 0, так как списочный массив пуст => укорачивается
        intoviySpisochniyMassiv.add(0, 354);
        intoviySpisochniyMassiv.add(1,988);
        intoviySpisochniyMassiv.add(2,319);
        intoviySpisochniyMassiv.add(3,3120);
        System.out.println("Размер массива: " + intoviySpisochniyMassiv.size());
        System.out.println("ArrayList "+ intoviySpisochniyMassiv); //список же, можно и так вывести)
        LinkedList<Integer> svazniySpisok = new LinkedList<>();
        svazniySpisok.add(32);
        svazniySpisok.add(222);
        svazniySpisok.addFirst(12);
        svazniySpisok.addLast(11);
        System.out.println("LinkedList "+ svazniySpisok); //также в виде массива выдает, 12 первый, 11 последний
        LinkedHashSet<String> hs = new LinkedHashSet<>(5);
        for (int i = 0; i < 5; i++) {
            hs.add("string " +i);
        }
        System.out.println("LinkedHashSet "+ hs); //да, об упорядоченности действительно говорить не приходится, зависит от алгоритма хеширования
        //Но, связное хеш-множество решило эту проблему)
        Random random = new Random(30);
        TreeSet<Integer> treeSet = new TreeSet<>();
        for (int i = 0; i < 30; i++) {
            treeSet.add(random.nextInt(15));
        }
        System.out.println("TreeSet" + treeSet);
        ArrayDeque<Integer> arrD = new ArrayDeque<>(); //С помощью методов push и pop использвоали двустороннюю очередь как стек
        arrD.push(12);
        arrD.push(18);
        System.out.print("ArrayDeque (as Stack) " + "[");
        while (arrD.peek()!=null){
            System.out.print(arrD.pop() + ", ");
        }
        System.out.print("]");
        System.out.println();
        Collections.addAll(hs, "1231", "1221323");
        System.out.println("Updated LinkedHashSet by addAll from Collections Class "+ hs);
        List<Object> list= new ArrayList<>();
        list.add(123);
        list.add(2.323);
        list.add("2131");
        //list.add("as");
        List obj = list; //при присваивании obj list без указания типа, теряется числовая типизация первого списка и идет присваивания
        //списка к типу Object
        Collection<Object> chgecked = Collections.checkedCollection(list, Object.class); // типизирвоали колекцию типом Object
        obj.add("312321");
        System.out.println(obj);
        List<String> listS = new ArrayList<>();
        listS.add("12");
        listS.add("132231");
        ((ArrayList<String>) listS).ensureCapacity(7);
        Collections.fill(listS, "ОЧЕНЬ МНОГО БУКАВ!!!");
        System.out.println(listS);
        Properties props = new Properties();
        props.put("key","value");
        props.list(System.out); //направляет свойства в стандартный поток вывода
        System.out.println(props); //выводит список свойств, в нашем случае key=value)))
        Date date = new Date();
        long l = 1597379213137L;
        date.setTime(l);
        System.out.println(date);
    }
}

