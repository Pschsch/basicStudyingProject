package com.maxonchik.studyingproj;

public class AddOpInf {
    private int repeatCount;

/*DSL - Domain Specific Language - предметно-ориентирвоанный язык. Дословно - спецализированный язык, нужен для какого-то
* узкого круга задач. Сборщики проектов имеют свой DSL и свой функционал. К сборщикам относятся: популярные Maven, Ant, Gradle.*/

    /* УСЛОВИЯ И ЦИКЛЫ
    Обычно программа выполняется строчка за строчкой , но иногда необходимо, чтобы код выполнялся н сразу, а при определенных
    условиях.
    Для этого у нас существует операторы if и else. If - если выполняется, else - если не выполняется.
    Можно использовать: if, if+else, if+else+if.
   Циклы: самые простые: while и do+while. Отличия: while выполняется до тех пор, пока соблюдается заданное
   условие. Do+while выполняется хотя бы один раз ,даже если условие не выполняется.
   Цикл while:
   Синтаксис: while(condition) operatorOrder;
   Условие в цикле while - логическое, цикл выполняется пока условие истинно.
   Если число итераций заранее известно, лучше воспользоваться циклом for, если неизвестно - циклом while.
   Если неоюходимо выполнить хотя бы одну итерацию - то ваш выбор do-while
   Do-while синтаксис:
   do
   {
   operator order;
   } while (condition){
   operator order;
   }
   Консольный ввод буферизируется построчно, как мы уже знаем. Это значит, что для передачи символов в консоль с помощью
   метода read(), приходится нажимать Enter(\n). А это ввод еще одного символа - символа перевода строки и возврата каретки.
   Эти символы хранятся в буфере вместе с другими символами до их использования в программе. Следовательно, помимо введенного
   символа, введется еще и символ перевода строки, что приведет к 2-кратному выполнению метода. Цикл do-while с параметром
   ignore в программе в файле PolymorphismTest.java отбрасывает эти символы, чтобы они не передавались в консоль, что будет
   искажать работу программы. Эти символы отбрасываются, пока не будет достигнут конец строки(конец буферной ячейки с символами)*/

    public void setRepeatCount(int repeatCount) {
        this.repeatCount = repeatCount;
    }

    public void LogOpResult(boolean r, boolean s) {
        System.out.println((r ? 1 : 0) + "\t" + (s ? 1 : 0) + "\t" + (r & s ? 1 : 0) + "\t" + (r | s ? 1 : 0) + "\t" + (r ^ s ? 1 : 0) + "\t" + (!r ? 1 : 0));
    }

    public int thisRepeatCount() {
        while (--repeatCount > 0)
            System.out.println("method is working" + repeatCount);
        return repeatCount;
    }
    public void EnglishAlph() {
        char ch = 'a';
        while (ch <= 'z') {
            System.out.print("\n" + ch);
            ch++;
        }
    }






    /*For - цикл конкретных условий, которые определяются в самом операторе.*/
    // for (int i=0; int<10; i++); //Сначала задается переменная, затем проверяется условие, затем происходит итерация
    /*общий синтаксис этого цикла: for(инициализация, условие, итерация){
    последовательность операторов}
    сли условие в цикле for изначально ложное, то код цикла не выполнится.
    Цикл for относится к одним из самых универсальных операторов в java.
    Для управления циклом for можно использовать несколько переменных(нихуахуа)
    for (i=0, j=10; i<j;i++, j++) через точку с запятой только значение;условие;итерация, внутри этих составляющих - через запятую.
    Можно использовать почти неограниченное количество операторов инициальизации и итерации, но на практике используются максимум 2,
    т.к такой цикл с большим кол-вом условий получится слишком громоздким.
    System.out.println("i "+i+"j "+j);
    /*Для выхода из циклов используется специальный оператор break. С помощью него, можно остановить выполнение кода в любом
    месте программы, организовать немедленный выход из цикла. break может быть применен в условии, его нужно записать как
    оператор, например: if (i*i<u) break;
    break применяется в любых циклах, даже в намерернно созданных бесконечными. Если break применен к вложенному циклу, то
    он применяется только к этому циклу, не трогая внешний цикл. Следует помнить 2 правила применения оператора break:
    1) Их может быть несколько, но применять их нужно очень продуманно, так как они могут нарушить структуру программы.
    2) если break применен к оператору switch, то он оказывает влияние только на него, не трогая циклы, связанные с ним.
    3) оператор break можно использовать в роли goto. Как правило, данный оператор несет вред коду программы, но в некоторых
    случаях может быть полезен. для этого оператор break омечается меткой: break метка. Метка - обозначение блока кода.
    пример приведен в полиморфизмТест в case'5'. Оператор break имеет метку one, которой обозначен блок кода one:{
    ДА,чтобы обозначить блок кода. необходимо перед началом блока кода написать метку и двоеточие: Example:{.
    Названием метки может служить любой доступный в джаве идентификатор с двоеточием. Возобновление программы происходит
    с конца именнованного блока, на который ссылается оператор break.*/
    /*Оператор continue. С помощью данного опретаора монжо организовать досрочное завершение шага итерации цикла в обход
    * обычной структуры управления циклом. Continue выполняет вынужденный переход к следующему шагу цикла, оставив предыдущий
    * без выполнения. Таким образом, continue служит своего рода дополнением к оператору break.В полиморфизмТест
    * приведен пример использвоания программы с оператором continue. В циклах while и do-while, оператор ontinue
    * передает управление непосредственно условному выражению, после чего продолжается процесс выполнения цикла.
    * В цикле for, сначалавычисляется итерационное выражение, затем проверяется условие, после чего цикл продолжается.
    * У continue тоже может быть метка, как и у оператора break.*/




    public int forRepeatCount() {
        for (repeatCount = 0; repeatCount < 10; ++repeatCount)
            System.out.println("cikl for " + repeatCount);
            return repeatCount;




    /*if - оператор ветвления. else отнонится к ближайшему оператору if, оторый находится с ним в одном блоке кода.
    * if-else-if общий синтаксис:
    * if(condition) operator;
    else if(condition) operator;
    else if(condition) operator;
    else operator;
    Если истинное условие найдется раньше конца конструкции, другие элементы конструкции опускаются.
    Новый оператор: switch - он же переключатель. Этот оператор обеспечивает многовариантное ветвление программы. он позволяет сделать выбор
    среди нескольких альтернативных вариантов выполнения программы.
    Синтаксис оператора switch:
    switch (expression){
    case const1:
    operators
    break;
    case const2:
    operators
    break;
    case const3:
    operators
    break;
    ....
    default: operator order
    }
    Оператор switch может управляться переменными типа char, byte, short, int и перечислением, а также объектом класса String.
    Ветвь default не является обязательной, если ни одно из условий не подойдет, то блок оператора switch вообще не выполнится.
    Если, значение переменной подошло к какому-то из условий, то оно выполняется, вплоть до оператора break(разрыв, конец). При
    выполнении этого опреатора break, switch заканчивает свою работу. case - ветвь оператора switch. Если break не применять, то
    после окончания выполнения условия, идет дальнейшее выполнения кода. Если значение константы соответсвует пустому case,
    то выполняется следующий case и т.д до нахождения case, содержащего какой либо исполняемый код.
    Оператор switch может быть вложенным. он может быть частью последовательности операторов другого оператора switch.
    Значения констант внутреннего и внешнего операторов switch могут повторяться не вызывая никаких конфликтов.
    switch (ch1){
    case 'A':
    operator order
        switch(ch2)
        case 'A':
        operator order
        break;
        case 'B':
        operator order
        break;
    case 'B':
    ...
 В некоторых ситуациях целесообразно вместо switch применять if-else-if.
 Это нужно там. где проверка условия не сводится к проверке совпадения или не совпадения со
 значением case. Также эта конструкция применяется для значений с плавающей точкой и других типов. которые отичаются от типов,
 предусмотренных для оператора switch.
 //Next achievement
 МАССИВЫ:
 Глава 5 Шилдт: Массивы, класс String, подразрядные операторы и тернарный оператор ? Новая разновидность for. ргументы ком строки
 Массив - совокупность однотипных переменных с общим именем. Массивы бывают двух видов: одномерные и многомерные. В основном,
 используются одномерные. Массивы очень часто используются, так как предоставляют средсвта для объединения связанных вместе
 переменных. Напрмиер, в массиве можно хранить максимальные суточные  температуры, зарегистрирвоанные в течение месяца,
 названия всех книг в домашней библиотеке и т.д. Главное преимущество массива - организация однотипных данных с целью простоты
 манипуляции с ними. массивы также облегчают сортировку данных.
 Массивы в Java реализованы в виде объектов. Массивы могут удаляться из памяти с помощью системы сборки мусора, как и любые другие объекты.
 Типы:
 Одномерный массив - список связанных между собой переменных. Например, можно хранить номера телефонов пользователей в таком
 массиве, счета матчей футбольных команд и т.д.
 Общий синтаксис одномерного массива:
 тип имя_массива[] - new тип[размер массива]; - тип массива называют еще базовым типом, [] - оператор объявления массива
 Базовый тип определяет тип данных каждого элемента массива. Рамер массива - число элементов массива. Так как массив- объект, он
 создается в два этапа: сначала создается ссылка на объект массива в виде имени_массива. Затем создается объект массиав в
 памяти и возвращается в виде ссылки имя_массива Оператор new следовательно выпоняет дял массивов ту же функцию, что и для
 всех других объектов в Java.
 пример массива: int sample[] = new int[10] - массив sample типа int с числом элементов массива типа int равным 10.
 Можно разделить объявление массива на 2 оператора, как и при создании объекта:
 int sample[];
 sample = new int[10]; - здесь уже не указывается оператор объявления массива, т.к sample уже ранее был объявлен как массив.
 Доступ к отдельным элементам массива реализуется с помощью индексов массива. Индекс - это позиция элемента в массиве.
 Индекс первого элемента массива в Java равен всегда 0(а не 1)!!! Индексы массива sample, например, варьируются от 0 до 9,
 так как число элементов этого массива равно 10 (итого 10 индексов). Индексирование массива осуществляется по номерам его элементов
 заключенным в квадратные скобки. Самый примитивный метод индексирвоания массива:
 sample[0] = i;
 sample[1] = u; и т.д...
 Но это делать проблематично и неудобно, если число элементов массива велико, то индексирвание займет много времени.
 Более оптимальным вариантом является индексирование массива с помощью цикла for:
 int i; - обязательно сделать глобальной переменной, чтобы она была доступна за пределами цкилов.
 for(i=0;i<10;i++){
 sample[i]=i;  // здесь элементам массива присваиваются значения i
 }
 for(i=0;i<10;i++){ здесь значение i обнуляется, так как происходит следующая операция присваивания, но значения i с предыдущего
 цикла остались в массиве sample[i]
 System.out.println("Элемент массива ["+i+"] равен "+sample[i]);
 } Итог: элемент массива [0] равен 0
 ... и т.д до 9.
 Структура массива sample после присваивания его элементам значений выглядит следующим образом:
 0          1           2           3           4           5           6           7           8           9
 sample[0]  sample[1]   sample[2]   sample[3]   sample[4]   sample[5]   sample[6]   sample[7]   sample[8]   sample[9]
Массивы часто используются в программирвоании, так как позволяют обрабатывать большое количество данных.
Например, можно написать программу, выводящую мин и макс значения массива:
int array[] = new int[3];   //
int min,max;                //  int min,max остются, так как не имеют отношения к инициализации массива:)
array[0]=392                //  Это можно заменить на int array[]={ 392, -199, 13 }
array[1]=-199;              //
array[2]=13;                //
for(i=0;i<4;i++){
if (array[i]<min) min=array[i]; //апоминание: операция присваивания присваивает значение справа переменной слева!!!!! не забывать!!
if (array[i]>max) max=array[i];
System.out.println(min+" and "+max); Выведет -199 and 392
В примре выше, массив заполнялся вручную по индексам: каждому индексу необходимо присвоить значение. Но можно это сделать
на стадии объявления массива(типа конструктора массива)
int array[] = {392, -199, 13} - в данном массиве значения автоматом присвоятся каждому индексу элемента массива. Кстати, как
можно заметить, здесь не использовался оператор new, но массив с заданными значениями все равно был создан. Задаваемые
значения обязательно берутся в фигурные скобки! Эти задаваемые значения называются инициализаторами массива, а процесс создания
массива таким образом - инициализацией массива. Значения слева направо соответсвуют индексам от 0 и выше.
Границы массива в Java очень сторго соблюдаются. при выходе за границу массива, например. в процессе выполнения цикла for
компилятор сгенерирует исключение ArrayIndexOutOfBoundsException и выполнение программы прекратится
int array[]=new int[10]
for (i=0; i<1000; i++)
array[i] = i; // когда значение i достигнет 10, наступит total ass, т.к последний элемент массива имеет индекс 9.
Методы сортировки массивов: прочитаем, пока таксовать будем
Упражнение на сортировку массивов сделаем в классе main. Готово, надо разобрать и прокомментировать, разобрали, поняли, как работает
Пузырьковая система эффективна только для небольших одномерных массивов. Есть более эффективные способы сортировки массивов,
о них далее.
Многомерные массивы - используются реже одномерных. В Java они представляют собой массивы массивов. Наиболее простыми многомерными
массивами являются двумерные массивы. Он, по сути, представляет собой Ряд одномерных массивов(грубо говоря, это таблица или
матрица!)
Чтобы объявить массив размеров a*b, где a и b -какие-то целые числа, используется след синтаксис:
int table[][]=new int[a][b]. Две пары квадратных скобок означают, что массив двумерный. Для обращения к элементу массива с индексами
3,5 , адрес этого элемента будет выглядеть table[3][5].
В примере ниже двумерный массив заполняется числами от 1 до 12.
int array12[] = new int[3][4];
int a,b;
for(a=0;a<3;a++);{      //цикл для строк
    for(b=0;b<4;b++);{  //Для заполнения двумерных массивов нужен вложенный цикл для столбцов
    array12[a][b]=a*4+b+1;
    System.out.println("array[a][b]");}
    }
Нерегулярные массивы:
При выделении ОЗУ для массива, достаточно указать число ячеек первого измерения массива. Число ячеек для второго измерения можно
уже указать отдельно для каждого первого измерения
например, для двумерного массива:
int TableArray[][]=new int[5][];
TableArray[0]=new int[3];
TableArray[1]=new int[4];
... и т.д . То есть, такое объявление массива дает нам возможность указать разное число ячеек в индексах первого измерения.
Так как двумерный массив - это массив массивов, соответсвенно во внешнем массиве можно указать длину внутренних массивов.
Нерегулярные массивы, в большинстве случаев, не используются, так как сложны для восприятия, но в некоторых специфичных случаях,
где они действительно необходимы, помогут повысить производительность приложения, сэкономив ОЗУ.
Трех- и более мерные массивы: размерность массивов может быть больше 2-х: 3-х, 4-х и даже выше.
Например, трехмерный массив 3*10*3 будет выглядеть:
int CubicArray[][][]=new int[3][10][3];
Инициализация многомерных массивов: как и с одномерными, для многомерных также можно использовать быструю инициализацию:
Для двумерного:
int TableArray[][]={
{3 , 27, 643, 42},
{65, -39, -48, 120},
{123, 123, 53465, 71247},
}; //т.е в данном случае мы реализовали массив 4*3. После фигурной скобки обязательно ставится разделитель инструкций, т.к
это объявление массива, т.е инструкция, которая должна быть завершена. Запятые после каждой фигурной скобки также обязательны, они
разделяют наши строки в массиве.
Быстрая инициализация трехмерного массива(чисто ачивка, just for fun) возьмем 3*3*3:
int VolumeArray[][][]={
{
{3,3,3}
{3,3,3}
{3,3,3}
},
{
{3,3,3}
{3,3,3}
{3,3,3}
},
{3,3,3}
{3,3,3}
{3,3,3},
};     // первые фигурные скобки - сам блок массива
Так вышло 3*3*3, каждый элемент кубической матрицы содержит значение 3.

Альтернативный синтакис объявления массивов: это когда квадратные скобки ставятся после типа массива. Это нужно для того, чтобы
можно было сразу объявить несколько массивов одного типа:
int[] array1, array2, array3;  //например так. Объявлять как объет нужно уже каждый массив, это помним! Один new - один объект.
Правда тоже самое будет, если объявить так: int array1[], array2[], array3[]
Особенно удобно, когда значение, возвращаемое методом -массив: int[] someMeth(){тело метода} - метод возвращает массив типа int.
 Присваивание ссылок на массивы:
 Как и в любых других объектах!!! Если присвоить одну переменную, ссылающуюся на массив другой переменной, другая переменная
 будет ссылаться на этот же массив! тут все как обычно!
 Переменная экземляра length:
 Тут поинтерсней) массив - это объект, каждый из которых обладает свойством length. length - свойство, содержащее в себе
 число ячеек массива(длина массива, length длина же, б****) Это свойство используют в условии при инициализации списка(одномерного
 массива) с помощью цикла for. Это удобнее, так как не нужно вручную отслеживать количество ячеек массива.
 Если использовать length для двухмерного массива, то length выдаст для него только число массивов
 в этом массиве. Чтобы получить длину каждого массива в этом массиве, нужно вызвать length для каждого массива с помощью
 добавления индекса: например: array12[2].length - выдаст значение количества ячеек в массиве array12 с индексом 2.
 С помощью length можно предотвращать возникновение исключений в связи с выходом за рамки массива при работе с несколькими
 массивами, например, при копировании одного в другой.
 Структуры данных: база(Про структуры данных, коллекции необходима ДОПОЛНИТЕЛЬНАЯ ЛИТЕРАТУРА!!):
 Существует 2 основных структуры данных - стек и очередь. В стеке реализуется принцип LIFO, в очереди -FIFO.
 1. Last in - first out. 2. First in - first out. По-английски: stack and queue.
 Поразрядные операции: в начале были рассмотретны операции арифметические и логические и сравнения(отношения). Java предусма-
 тривает также использование побитовых или поразрядным операций. В поразрядных опреациях могут принимать участие только типы
 char, int, long, short, byte. Этот вид операций используется в основном для проверки, установки и сдвига отдельных разрядов
 числа. Всего поразрядных операций 7:
 Поразрядное И &
 оразрядное ИЛИ |
 Поразрядное исключающее ИЛИ ^
 >> - двиг вправо
 << - сдвиг влево
 >>> - сдвиг вправо без знака
 ~ - исключающее НЕ (дополнение до 1)
 Поразрядные И ИЛИ исключающие ИЛИ и НЕ выполняют те же функции, что и их логические аналоги,  но в отличие от них, они оперируют
 отедльными довичными разрядами.
 а    b   a & b   a | b   a ^ b   ~a
 0    0     0       0       0      1
 1    0     0       1       1      0
 0    1     0       1       1      1
 1    1     1       1       0      0
 Поразрядная И сбрасывает единицы в битах двоичных разрядов.
    11010100  //Операнд над которым проводится операция
 &  10010000= //Двоичное представление опреанда вводимого для обнуление отдельных битов.
    10010000  Единицы сбрасываются до нулей, если при выполнении операции в одном хотябы разряде содержится 0. Эта операция м\б
    исползована для сброса регистра букв в системе Юникода. Если представить число 65503 в виде двоиного кода, то
    получится 1111111111011111, т.е сбросится 6-й бит при выполнении операции у исходного операнда.
    Данную операцию можно использовать для переведения значения типа byte в двоичный формат с помощью цикла for и оператора
    if.
    int t;
    byte val;
    val=123;
    for(t=128;t>0;t=t/2){
    if((val&t)!=0) System.out.println("1");
    else System.out.println("0");}
    поразрядное ИЛИ наоборот устанавливает значение 1
    Исключающее ИЛИ меняет бить с 0 на 1, и с 1 на 0 таким образом: 1^1=0; 0^0=1; 1^0=1(и наоборот). С помощью данной операции
    можно шифровать сообщения)))
    поразрядное НЕ инвертирует двоичные разряды в операнде
    Операции сдвига: в Java предусмотрена возможность сдвига битов на заданное число позиций: значение << число_битов.
    При сдивге влево, младшие биты заполняются нулями. При сдвиге вправо сложнее: при сдивге вправо не трогается старший разряд,
    отвечаютющий за знак числа (0-полож, 1-отриц). Отрицательные числа представляются в виде дополнения до двух, т.е обратные биты
    положительного аналога + единица. Например, 00000001 - единица, 11111110+1=11111111 - минус единица(пример дополнения до двух)
    При использовании операции сдвига вправо без знака, то старшие разряды освободившиеся заполняются нулями. Если биты сдвинуть
    за пределы битовой ячейки(это возможно), то биты теряются.
Операции сдивга вправо и влево позволяют умножать и делить число на 2!!!)) При сдвиге влево умножается на 2, при сдивге вправо,
делится. Правда необходимо следить, чтобы биты не выпали за пределы ячейки. Также есть составные поразрядные операции присваивания.
Тернарный опертаор ? - оператор с тремя операторами. Синтаксис:
Выр_1 ? Выр_2 : Выр_3, где Выр_1 типа boolean, выр_2 и 3 - любой тип, кроме void. Выр_2 исполняется при значении выр_1 true
Выр_3 исполняется при выр_1 при значении false.


*/

    }
}